<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>innovaphone SDK - WebserverPlugin</title>
    <link rel="stylesheet" href="../../web1/doc/innovaphone.doc.css" type="text/css" />
    <link rel="stylesheet" href="../../web1/doc/vs.css">
</head>

<body>
    <script src="../../web1/doc/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <h1>Webserver Plugin</h1>
    <p>
		One of the cores of the innovaphone App Platform is the webserver (see <a href="../../doc/introduction.htm#Core">"The core of the innovaphone App Platform"</a> for details). An App can plugin itself to the webserver
		to receive HTTP or websocket requests. If an App whants to offer an JavaScript UI too, it actually must plugin itself into the webserver. However, this can be done by using the IWebserverPlugin interface.<br/><br/>
		The app needs to give a path to the IWebserverPlugin on creation and call IWebserverPlugin::HttpListen(), IWebserverPlugin::WebsocketListen() or IWebserverPlugin::PassthroughListen() to receive the different requests.
		The path given to the interface on creation will be the applications web root. So if e. G. the system is accassibly under http://192.168.1.100 and the application passes "/myapp" as path, it will be accessibly under
		http://192.168.1.100/myapp, wich will be the apps root. The root of the system is reserved for the Manager of the innovaphone App Platform. The application will receive every request to that path and below.
	</p>
	<p>
		The webserver plugin is a collection of a bunch of interfaces, used for web communication. Each web request type (like GET, PUT, POST, ...) has it's own interface to handle the request. They also have ther own user class
		an application must subclass and pass to the IWebserverPlugin isntance to accept a request. This user class is responsible for sending and receiveing data, settings additional informations (like chunk encoded transfer, the number
		of bytes the response have, the data type of the response).
	</p>
	<p>
		The IWebserverPlugin also supports static files. Those files will be converted to a C++ file, compiled and finally linked to the applications binary. This files will be automatically handled by the IWebserverPlugin. That means, that
		a request of a static file never will reach the applications coded. Instead, the IWebserverPlugin will send the file to the webserver who will send it to the client that requested the file. So for each incomming GET request, the
		IWebserverPlugin will at first look at the list of static files, if the request is for one of them. If not, the UWebserverPlugin::WebserverHttpListenResult() function will be called, so that the application can respond to that request
		or deny it. Note that the static files name also can include subfolder. So a static file can be linked to the applications binary as "images/icon.png", it can be accessed by a client at "http://&lt;server-address&gt;/&lt;applications-root&gt;/images/icon.png".
	</p>
	
    <h2>File information</h2>
    <table style="margin-left:-12px">
        <tr><td><b>File</b></td><td>common/interface/webserver_plugin.h<br/><br/></td></tr>
        <tr><td><b>Public functions</b></td><td>
                                                <a href="#CreateWebserverPluginProvider">CreateWebserverPluginProvider</a><br/>
                                                <a href="#GetResponseTypeForFileName">GetResponseTypeForFileName</a><br/>
                                                <a href="#WSCancelTypeToStr">WSCancelTypeToStr</a><br/>
                                                <a href="#WSPCloseReasonToStr">WSPCloseReasonToStr</a><br/>
                                                <a href="#WSWebdavResultToStr">WSWebdavResultToStr</a><br/>
                                                <br/>
                                            </td></tr>
        <tr><td><b>Classes</b></td><td>
                                       <a href="#IWebserverPluginProvider">IWebserverPluginProvider</a><br/>
                                       <a href="#IWebserverPlugin">IWebserverPlugin</a><br/>
                                       <a href="#UWebserverPlugin">UWebserverPlugin</a><br/>
                                       <a href="#IWebserverGet">IWebserverGet</a><br/>
                                       <a href="#IWebserverGetRange">IWebserverGetRange</a><br/>
                                       <a href="#UWebserverGet">UWebserverGet</a><br/>
                                       <a href="#IWebserverPost">IWebserverPost</a><br/>
                                       <a href="#UWebserverPost">UWebserverPost</a><br/>
                                       <a href="#IWebserverPut">IWebserverPut</a><br/>
                                       <a href="#UWebserverPut">UWebserverPut</a><br/>
                                       <a href="#IWebserverPropfind">IWebserverPropfind</a><br/>
                                       <a href="#UWebserverPropfind">UWebserverPropfind</a><br/>
                                       <a href="#IWebserverMove">IWebserverMove</a><br/>
                                       <a href="#UWebserverMove">UWebserverMove</a><br/>
                                       <a href="#IWebserverMkCol">IWebserverMkCol</a><br/>
                                       <a href="#UWebserverMkCol">UWebserverMkCol</a><br/>
                                       <a href="#IWebserverCopy">IWebserverCopy</a><br/>
                                       <a href="#UWebserverCopy">UWebserverCopy</a><br/>
                                       <a href="#IWebserverDelete">IWebserverDelete</a><br/>
                                       <a href="#UWebserverDelete">UWebserverDelete</a><br/>
                                       <a href="#IWebserverLock">IWebserverLock</a><br/>
                                       <a href="#UWebserverLock">UWebserverLock</a><br/>
                                       <a href="#IWebserverUnlock">IWebserverUnlock</a><br/>
                                       <a href="#UWebserverUnlock">UWebserverUnlock</a><br/>
                                       <a href="#IWebserverProppatch">IWebserverProppatch</a><br/>
                                       <a href="#UWebserverProppatch">UWebserverProppatch</a><br/>
                                       <a href="#IWebserverOptions">IWebserverOptions</a><br/>
                                       <a href="#UWebserverOptions">UWebserverOptions</a><br/>
                                       <a href="#IWebsocket">IWebsocket</a><br/>
                                       <a href="#UWebsocket">UWebsocket</a><br/>
                                       <a href="#IWebserverPassthrough">IWebserverPassthrough</a><br/>
                                       <a href="#UWebserverPassthrough">UWebserverPassthrough</a><br/>
                                       <br/>
                                   </td></tr>
        <tr><td><b>Data types</b></td><td>
                                          <a href="#WS_MAX_PATH_LENGTH">WS_MAX_PATH_LENGTH</a><br/>
                                          <a href="#WS_MAX_DATA_SIZE">WS_MAX_DATA_SIZE</a><br/>
                                          <a href="#WS_RESPONSE_CHUNKED">WS_RESPONSE_CHUNKED</a><br/>
                                          <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a><br/>
                                          <a href="#wsp_path_type_t">wsp_path_type_t</a><br/>
                                          <a href="#ws_webdav_result_t">ws_webdav_result_t</a><br/>
                                          <a href="#wsr_type_t">wsr_type_t</a><br/>
                                          <a href="#wsr_flags_t">wsr_flags_t</a><br/>
                                          <a href="#wsp_close_reason_t">wsp_close_reason_t</a><br/>
                                          <a href="#ws_close_reason_t">ws_close_reason_t</a><br/>
                                          <a href="#ws_request_type_t">ws_request_type_t</a><br/>
                                          <a href="#ws_update_auth_result_t">ws_update_auth_result_t</a><br/>
                                          <a href="#IWebserverGetRange_range_type_t">IWebserverGetRange::range_type_t</a><br/>
                                          <br/>
                                      </td></tr>
        <tr><td><b>Structures</b></td><td>
                                            <a href="#ws_type_sfx_t">ws_type_sfx_t</a><br/>
                                            <br/>
                                        </td></tr>
          <tr><td><b>Examples</b></td><td>
                                          <a href="#ExampleIWebserverPlugin_IWebserverGet">IWebserverPlugin - IWebserverGet</a><br/>
                                          <a href="#ExampleIWebserverPlugin_IWebsocket">IWebserverGet - IWebsocket</a><br/>
                                          <br/>
                                      </td></tr>
    </table>
	
	
	<h1>Functions</h1>
    <h2>Functions to initialize</h2>
    <pre><code class="language-cpp">extern IWebserverPluginProvider * CreateWebserverPluginProvider();</code></pre>
    <h3>Overview</h3>
    This function must be used to create an instance of the IWebserverPluginProvider. With that instance, an IWebserverPlugin instance can be created.
    <br/><br/>

    <div id="CreateWebserverPluginProvider" class="fnhead" style="margin-top:5px">CreateWebserverPluginProvider</div>
    <dd>
        <h4>Return value</h4>
        The IWebserverPluginProvider instance. That instance can be freed as soon as it no longer is used by calling the C++ delete operator.
    </dd>
	
    <h2>Helper functions</h2>
	<pre><code class="language-cpp">inline wsr_type_t GetResponseTypeForFileName(const char * fileName);
inline const char * WSCancelTypeToStr(wsr_cancel_type_t c);
inline const char * WSPCloseReasonToStr(wsp_close_reason_t cr);
inline const char * WSWebdavResultToStr(ws_webdav_result_t r);
</code></pre>
	<h3>Overview</h3>
	This functions are helper function to make development life a little bit easier. While GetResponseTypeForFileName() iterrates trough the list of resource types to get the resource type for a given file prefix, the other functions
	are for mapping an enum type to a human readable string. That helps especially for debugging purposes. 
    <br/><br/>

    <div id="GetResponseTypeForFileName" class="fnhead" style="margin-top:5px">GetResponseTypeForFileName</div>
    <dd>
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>filename</b></td><td>The filename to figure out the type to return for that request. That type will be written in the answers HTTP header.</td></tr>
        </table>

        <h4>Return value</h4>
        The wsr_type_t resource type to set for a GET request. The response type will be returned depending on the file prefix. See <a href="#wsr_type_t">wsr_type_t</a> for more information.
    </dd>

    <div id="WSCancelTypeToStr" class="fnhead" style="margin-top:5px">WSCancelTypeToStr</div>
    <dd>
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>c</b></td><td>The wsr_cancel_type_t value to convert to a string.</td></tr>
        </table>

        <h4>Return value</h4>
        The given wsr_cancel_type_t value as human readable string, so that it can be written to a log instead of only a number value.
    </dd>

    <div id="WSPCloseReasonToStr" class="fnhead" style="margin-top:5px">WSPCloseReasonToStr</div>
    <dd>
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsp_close_reason_t <b>cr</b></td><td>The wsp_close_reason_t value to convert to a string.</td></tr>
        </table>

        <h4>Return value</h4>
        The given wsp_close_reason_t value as human readable string, so that it can be written to a log instead of only a number value.
    </dd>


    <div id="WSWebdavResultToStr" class="fnhead" style="margin-top:5px">WSWebdavResultToStr</div>
    <dd>
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>r</b></td><td>The ws_webdav_result_t  value to convert to a string.</td></tr>
        </table>

        <h4>Return value</h4>
        The given ws_webdav_result_t value as human readable string, so that it can be written to a log instead of only a number value.
    </dd>

	
	<h1>Classes</h1>
    <a name="IWebserverPluginProvider"><h2>IWebserverPluginProvider</h2></a>
    <pre><code class="C++">class IWebserverPluginProvider {
public:
    virtual ~IWebserverPluginProvider() {}
    virtual class IWebserverPlugin * CreateWebserverPlugin(class IIoMux * const iomux,
                                                           class ISocketProvider * localSocketProvider,
                                                           class UWebserverPlugin * const user,
                                                           const char * webserverAddress,
                                                           const char * appWebRoot,
                                                           class IInstanceLog * const log);
};</code></pre>

    <h3>Overview</h3>
    The IWebserverPluginProvider is used to create an instance of IWebserverPlugin. Multiple instances of IWebserverPlugin can be created, but generally only one IWebserverPlugin is needed for each AppInstance. The created IWebserverPlugin
	does not depend on the IWebserverPluginProvider it had been created from. So the IWebserverPluginProvider instance can be deleted as soon as no longer needed.
	
    <h3>Public functions</h3>
    <div class="fnhead">CreateWebserverPlugin</div>
    <dd>
        Creates the IWebserverPlugin instance. The application is responsible to free the instance when no longer needed. This must not be done before calling IWebserverPlugin::Shutdown() and
		receiveing the UWebserverPlugin::WebserverPluginShutdownComplete() callback.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">class IIoMux * const <b>iomux</b></td><td>The <a href="../os/iomux.htm#IIoMux">IIoMux</a> instance the IWebsocketPlugin instance will be registered to.</td></tr>
            <tr><td class="param">class ISocketProvider * <b>localSocketProvider</b></td><td>The <a href="socket.htm#ISocketProvider">ISocketProvider</a> instance that will be used to create a local socket.</td></tr>
            <tr><td class="param">class UWebserverPlugin * const <b>user</b></td><td>The <a href="../os/iomux.htm#IIoMux">IIoMux</a> instance the IWebsocketPlugin instance will be registered to.</td></tr>
            <tr><td class="param">const char * <b>webserverAddress</b></td><td>The address of the webserver.  Will be passed to the application from the manager.</td></tr>
            <tr><td class="param">const char * <b>appWebRoot</b></td><td>The root of the app inside the web structure. Can not be the root of the system ("/"), as well as not a folder already used by an other app.</td></tr>
            <tr><td class="param">class IInstanceLog * const <b>log</b></td><td>The <a href="../lib/appservice.htm#IInstanceLog">IInstanceLog</a> instance used for loging purposes.</td></tr>
        </table>

        <h4>Return value</h4>
        The IWebserverPlugin instance It must be freed by the C++ operator delete, if no longer be used.
    </dd>

    <a name="IWebserverPlugin"><h2>IWebserverPlugin</h2></a>
    <pre><code class="C++">class IWebserverPlugin {
public:
    virtual ~IWebserverPlugin() {};

    virtual void SendCertificate(const char * password, const byte * certBuf, size_t certLen, const char * hostName = nullptr, UWebserverPlugin * user = nullptr);
    virtual void HttpListen(const char * path = nullptr, UWebserverPlugin * user = nullptr, const char * authUser = nullptr, const char * authUserPwd = nullptr, const char * staticFilePrefix = nullptr);
    virtual void HttpListen(const char * path, UWebserverPlugin * user, bool dynamicAuth, const char * staticFilePrefix = nullptr);
    virtual void PassthroughListen(const char * path = nullptr, UWebserverPlugin * user = nullptr);
    virtual void WebsocketListen(const char * path = nullptr, UWebserverPlugin * user = nullptr);
    virtual void SetAuthConfig(const char * path, const char * authUser = nullptr, const char * authPwd = nullptr);
    virtual void SetAuthConfig(const char * path, bool enableDynAuth);

    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void Redirect(const char * newDestination);

    virtual void Accept(class UWebserverGet * const user);
    virtual void Accept(class UWebserverPost * const user);
    virtual void Accept(class UWebserverPut * const user);
    virtual void Accept(class UWebserverPassthrough * const user);
    virtual void Accept(class UWebserverPropfind * const user);
    virtual void Accept(class UWebserverMove * const user);
    virtual void Accept(class UWebserverMkCol * const user);
    virtual void Accept(class UWebserverCopy * const user);
    virtual void Accept(class UWebserverDelete * const user);
    virtual void Accept(class UWebserverLock * const user);
    virtual void Accept(class UWebserverUnlock * const user);
    virtual void Accept(class UWebserverProppatch * const user);
    virtual void Accept(class UWebserverOptions * const  user);
    virtual void WebsocketAccept(class UWebsocket * user);

    virtual void RequestUserPasswordResult(dword connectionID, const char * user, const char * password);

    virtual void Close();
};</code></pre>

    <h3>Overview</h3>
    The IWebsocketPlugin is the interface used by an app to hook itself into the webserver of the innovaphone App Platform. Doing so allows the app to receive HTTP requests (including WebDav) as well as Websocket requests. This is primarily
	used to provide and communicate with a JavaScript UI. However, it can be used for HTTP communication beside this as well.<br/><br/>
    To receive request, an application first must call one of the listen functions of IWebserverPlugin. The functions can be called multiple times to listen to different paths, but only once per path. An exception is the difference of the listen
    call. So WebsocketListen() can be called for a path that alrady had been used for HttpListen(). But be carefull with the order the listen calls will be made. When an application calls Listen() (HttpListen(), WebsocketListen() or PassthroughListen()) more than
    once to listen to different paths, this calls are handled asynchronious. That means, that after the first HttpListen() had been handled, an incomming connection can already accepted before the second HttpListen() had been handled by the Webserver
    (same for WebsocketListen() and PassthroughListen()). So if the second one goes to a subpath, that can lead to wrong listen result calls. <br/>
    For example, an applications whants to listen to "/myapp" and "/myapp/image". But because a listen to "/myapp" also leads for a HttpListenResult if "/myapp/images/myimage.png" is requested, but "/myapp/images" is not yet registerd
    for listen, HttpListenResult will be called with a path and registeredPathForRequest value that the application won't expect. To prevent that, the HttpListen() must be called in opposide order. So in our example,
    at first HttpListen("/myapp/images") should be called before HttpListen("/myapp"). For passthrough (see below), that problem doesn't exist. Because To now more about the listen result function, see <a href="#UWebserverPlugin">UWebserverPlugin</a>.<br/><br/>
	The Webserver itself will resolve a request and redirects it in a prepared maner to the IWebsocketPlugin resbonsible for that request. So the App generally don't need to handle any HTTP protocoll (as long as the IWebsocketPlugin is not used
	for passthrough, whicht gives full control over the protocoll to the app). Generally, an incomming request will lead to an aproriate UWebserverPlugin::WebserverPlugin*ListenResult() (while * can be Http, Websocket or Passthrough). The only
	exception is an incomming GET request. In that case, the IWebserverPlugin at first will look for static files linked to the app, that can fulfill the request. If found, the file will be send to the Client and therefore the request will be respondet from
	the IWebserverPlugin internally. The application won't be notified. So if an app only whants to provide static files, there is no need to implement an UWebserverPlugin::WebserverPluginHttpListenResult().<br/><br/>
	A path can be registered to be password protected. This can be either an fixed user and password, that will not change during the applications running time, or in a dynamic way, which means that for each request the webserver asks the
	application for the password of the user that tries to access. It is alos possible to only password protext a subfolder, by calling a IWeberverPlugin::HttpListen() to the apps root without password information and calling it again for a subfolder,
	telling that that subfolder needs authentication. Authentication is only supportet for HTTP listen, not for websocket or pass through.<br/><br/>
	While all request will be handled by the webserver itself, so that an application has no need to handle the HTTP protocol, it can be necessary some times to have control on what's going on. So an application can also call
	IWebserverPlugin::PassthroughListen(), which will end up in an UWebserverPlugin::WebserverPluginPassthroughListenResult() for each incoming request. The difference is, that the request will be passed through to the app, ans so the app
	needs to parse the HTTP header and buld up a correct HTTP header for response (also handle websocket or whole authentication stuff, if needed). Parsing and creating a HTTP header can be done with the
	<a href="../lib/httplib.htm#HTTPLib_HTTPHeader">HTTPLib::HTTPHeader</a> and <a href="../lib/httplib.htm#HTTPLib_HTTPParser">HTTPLib::HTTPParser</a> classes.
	
	<h3>Logging</h3>
	To enable logging for IWebserverPlugin, the flag LOG_WEBSERVER_TRAFIC must be set in the managers diagnostic settings.
	
    <h3>Public functions</h3>
    <div class="fnhead">HttpListen (overloaded)</div>
    <dd>
        Starts to listen to incomming HTTP requests. If an incomming request as a GET request and can be resolved with to the app linked static files, the request will be handled internally. Else the application will receive a callback to
		response or cancel the request. And application must call the function at least for the appications root (with path = nullptr), even if only whant to provide static files.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>path</b></td><td><i>(Default nullptr)</i> The path to listen to. Note that that path always will be under the applications web root, defined when creating the IWebserverPlugin. If this value is nullptr, the root will be used.</td></tr>
            <tr><td class="param">UWebserverPlugin * <b>user</b></td><td><i>(Default nullptr)</i> The user to inform about an incoming request. This helps to have different UWebserverPlugin instances for different path to list. If set to nullptr, the same user as passed to IWebserverPluginProvider::Create() will be used (which hovewer is the default user).</td></tr>
            <tr><td class="param">const char * <b>authUser</b></td><td><i>(Default nullptr)</i> The user to use for authentication. If not is null, authentication for the given pass will be activated.</td></tr>
            <tr><td class="param">const char * <b>authPassword</b></td><td><i>(Default nullptr)</i> The password to use for authentication.</td></tr>
            <tr><td class="param">const char * <b>staticFilePrefix</b></td><td><i>(Default nullptr)</i> If not is nullptr, the value given will be used as prefix for static files. This can also include '/' to simulate an other path.</td></tr>
        </table>

		<h4>Callbacks</h4>
		On success, an incoming HTTP request will lead to a callback of UWebserverPlugin::WebserverPluginHttpListenResult(), if the request is not a get request and, in that case, can't be resolved with an static file linked to the applications binary.
 		If an error occurres, USocket::SocketShutdown() will be called. Details of that error can be found inside the log, if logging is activated. Reason can be one of the following values:<br/>
        <table style="margin-left: 20px">
            <tr><td><b>WSP_REGISTER_PATH_INVALID</b></td><td>The path given to register is invalid.</td></tr>
            <tr><td><b>WSP_PATH_ALREADY_REGISTERD</b></td><td>An other application already is listening to that path.</td></tr>
            <tr><td><b>WSP_ADDRESS_INVALID</b></td><td>The address to connect to the webserver is invalid.</td></tr>
        </table>
		
        <h4>Remarks</h4>
        This function is overloaded (see below).<br/>
		Calling IWebserverPlugin::HttpListen() more than once to the same path will lead to an assertion. If tryed to called it for a path already registered by an other application, the listen will be rejected by the webserver.<br/>
		However, the connection to the connection will be established the fist time, one of the IWebserverPlugin::*Listen() functions. The listen calls will be cached, so if the connection get lost, the IWebserverPlugin will connect
		to the webserver again and also makes the listen calls again, too.
    </dd>
	
    <div class="fnhead">HttpListen (overloaded)</div>
    <dd>
        This overloaded version does the same as described above. The difference is, that this version will be used to activate dynamic authentication, which means that the webserver asks the application for a password of a user that
		tries to connect. If the flag dynamicAuth is set to false, the function acts like calling the function above with authUser set to nullptr.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>path</b></td><td>The path to listen to. Note that that path always will be under the applications web root, defined when creating the IWebserverPlugin. If this value is nullptr, the applications root will be used.</td></tr>
            <tr><td class="param">UWebserverPlugin * <b>user</b></td><td>The user to inform about an incoming request. This helps to have different UWebserverPlugin instances for different path to list. If set to nullptr, the same user as passed to IWebserverPluginProvider::Create() will be used (which hovewer is the default user).</td></tr>
            <tr><td class="param">bool <b>dynamicAuth</b></td><td>If true, dynamic authentication will be activated. That means, that the Webserver asks the application for the password for a user that tries to authenticate.</td></tr>
            <tr><td class="param">const char * <b>staticFilePrefix</b></td><td><i>(Default nullptr)</i> If not is nullptr, the value given will be used as prefix for static files. This can also include '/' to simulate an other path.</td></tr>
        </table>

		<h4>Callbacks</h4>
		On success, an incoming HTTP request will lead to a callback of UWebserverPlugin::WebserverPluginHttpListenResult(), if the request is not a get request and, in that case, can't be resolved with an static file linked to the applications binary.
		If a user tries to authenticate, the Webserver asks the app for the password of the user who tries to authenticate by calling UWebserverPlugin::WebserverPluginRequestUserPassword(). The password must be sent using
		IWebserverPlugin::RequestUserPasswordResult() (see below).<br/>
 		If an error occurres, USocket::SocketShutdown() will be called. Details of that error can be found inside the log, if logging is activated. Reason can be one of the following values:<br/>
        <table style="margin-left: 20px">
            <tr><td><b>WSP_REGISTER_PATH_INVALID</b></td><td>The path given to register is invalid.</td></tr>
            <tr><td><b>WSP_PATH_ALREADY_REGISTERD</b></td><td>An other application already is listening to that path.</td></tr>
            <tr><td><b>WSP_ADDRESS_INVALID</b></td><td>The address to connect to the webserver is invalid.</td></tr>
        </table>
		
        <h4>Remarks</h4>
        This function is overloaded (see below).<br/>
		Calling IWebserverPlugin::HttpListen() more than once to the same path will lead to an assertion. If tryed to called it for a path already registered by an other application, the listen will be rejected by the webserver.<br/>
		However, the connection to the connection will be established the fist time, one of the IWebserverPlugin::*Listen() functions. The listen calls will be cached, so if the connection get lost, the IWebserverPlugin will connect
		to the webserver again and also makes the listen calls again, too.<br/>
    </dd>
	
    <div class="fnhead">PassthroughListen</div>
    <dd>
		An appliction can register itself for passthrough. Y request to that path, whatever kind of request, will be completly redirected to the appliaction. That means, that the application is responsible for handling the HTTP 	header (the incoming
		and outgoing) as well as all the other HTTP protocoll relarted stuff. The Webserver itself does nothing than passing through the bytestream between the client and the application. This can be done with the help of the
		<a href="../lib/httplib.htm#HTTPLib_HTTPHeader">HTTPLib::HTTPHeader</a> and <a href="../lib/httplib.htm#HTTPLib_HTTPParser">HTTPLib::HTTPParser</a> classes. PassthroughListen() only should be used if it is really necessary, generally
		it is recommended to let the Webserver itself handle all of the HTTP related stuff.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>path</b></td><td>The path to listen to for passthrough. Note that that path always will be under the applications web root, defined when creating the IWebserverPlugin. If this value is nullptr, the applications root will be used.</td></tr>
            <tr><td class="param">UWebserverPlugin * <b>user</b></td><td>The user to inform about an incoming request. This helps to have different UWebserverPlugin instances for different path to list. If set to nullptr, the same user as passed to IWebserverPluginProvider::Create() will be used (which hovewer is the default user).</td></tr>
        </table>

		<h4>Callbacks</h4>
		On success, an incoming request will lead to a callback of UWebserverPlugin::WebserverPluginPassthroughListenResult().<br/>
 		If an error occurres, USocket::SocketShutdown() will be called. Details of that error can be found inside the log, if logging is activated. Reason can be one of the following values:<br/>
        <table style="margin-left: 20px">
            <tr><td><b>WSP_WEBSOCKET_PATH_INVALID</b></td><td>The path given to listen to websocket connection is invalid.</td></tr>
            <tr><td><b>WSP_WEBSOCKET_PATH_ALREADY_LISTENING</b></td><td>An other application already is listening to that path.</td></tr>
            <tr><td><b>WSP_ADDRESS_INVALID</b></td><td>The address to connect to the webserver is invalid.</td></tr>
        </table>
		
        <h4>Remarks</h4>
        Pathrough always will be handled with priority. So if IWebserverPlugin::HttpListen() and IWebserverPlugin::PassthroughListen() will be called with the same path, only the passthrough will be handled.
    </dd>

    <div class="fnhead">WebsocketListen</div>
    <dd>
        Listens for incomming webocket connection to the given path. WebsocketListen() can be called for a path that had been used for HTTPListen() before.
        
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>path</b></td><td>The path to listen to for websocket conenctions. Note that that path always will be under the applications web root, defined when creating the IWebserverPlugin. If this value is nullptr, the applications root will be used.</td></tr>
            <tr><td class="param">UWebserverPlugin * <b>user</b></td><td>The user to inform about an incoming websocket request. This helps to have different UWebserverPlugin instances for different path to list. If set to nullptr, the same user as passed to IWebserverPluginProvider::Create() will be used (which hovewer is the default user).</td></tr>
        </table>

		<h4>Callbacks</h4>
		On success, an incoming Websocket request will lead to a callback of UWebserverPlugin::WebserverPluginWebsocketListenResult().<br/>
		If a user tries to authenticate, the Webserver asks the app for the password of the user who tries to authenticate by calling UWebserverPlugin::WebserverPluginRequestUserPassword().<br/>
 		If an error occurres, USocket::SocketShutdown() will be called. Details of that error can be found inside the log, if logging is activated. Reason can be one of the following values:<br/>
        <table style="margin-left: 20px">
            <tr><td><b>WSP_WEBSOCKET_PATH_INVALID</b></td><td>The path given to listen to websocket connection is invalid.</td></tr>
            <tr><td><b>WSP_WEBSOCKET_PATH_ALREADY_LISTENING</b></td><td>An other application already is listening to that path.</td></tr>
            <tr><td><b>WSP_ADDRESS_INVALID</b></td><td>The address to connect to the webserver is invalid.</td></tr>
        </table>
		
        <h4>Remarks</h4>
        It is allowed to use the same path for IWebserverPlugin::WebsocketListen() as used for IWebserverPlugin::HttpListen().
    </dd>

    <div class="fnhead">SetAuthConfig (overloaded)</div>
    <dd>
        Must be called if the configuration for authentication of a path should be changed. The changes will become active immediately. This overloaded version will be used to enable static authentication with the given username and password. So multiple calls to that function can be used to change the username or password, too. Setting them both to nullptr, will deactivate authentication for the given path, independent whether if static or dynamic authentication is currently active.
        
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>path</b></td><td>The path to listen to change the authentication configuration for (without the app web root). If this is nullptr, "/" or "", the app webroot will be used.</td></tr>
            <tr><td class="param">const char * <b>authUser</b></td><td><i>(Default: nullptr)</i> The user name to use for authentication. If this value is not nullptr, the authentication will be enabled or changed to static authentication.</td></tr>
            <tr><td class="param">const char * <b>authPwd</b></td><td><i>(Default: nullptr)</i> The password to use for authentication.</td></tr>
        </table>

		<h4>Callbacks</h4>
        The call to that function will lead to a UWebserverPlugin::SetAuthConfigResult() callback. The result of the action will be reported with one of the <a href="#ws_update_auth_result_t">ws_update_auth_result_t</a> values.
		
        <h4>Remarks</h4>
        This version activates (or changes the parameters for) static authentication. It also only can be called for a path that had been passed to a previous HTTPListen() call. 
    </dd>

    <div class="fnhead">SetAuthConfig (overloaded)</div>
    <dd>
        Must be called if the configuration for authentication of a path should be changed. The changes will become active immediately. This overloaded version will be used to enable dynamic authentication. Passing false as enableDynAuth, will deactivate authentication for the given path, independent whether if static or dynamic authentication is currently active.
        
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>path</b></td><td>The path to listen to change the authentication configuration for (without the app web root). If this is nullptr, "/" or "", the app webroot will be used.</td></tr>
            <tr><td class="param">bool <b>enableDynAuth</b></td><td>True, to enable or change to dynamic authentication. If false, authentication will be deactivated.</td></tr>
        </table>

		<h4>Callbacks</h4>
        The call to that function will lead to a UWebserverPlugin::SetAuthConfigResult() callback. The result of the action will be reported with one of the <a href="#ws_update_auth_result_t">ws_update_auth_result_t</a> values.
		
        <h4>Remarks</h4>
        SetAuthConfig() only can be called for a path that had been passed to a previous HTTPListen() call. However, it also can be used to switch from dynamic authentication to static authentication, if needed.
    </dd>
    
    <div class="fnhead">SendCertificate</div>
    <dd>
		The Webserver supports TLS encrypted connections. This function let define the certficate to use. Generally there is no need for an application to call this function, becuse the certificate will be set by the Manager.
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>password</b></td><td>The password to use with the certificate.</td></tr>
            <tr><td class="param">const byte * <b>certBuf</b></td><td>The buffer with the certificate to send. Must not be nullptr.</td></tr>
            <tr><td class="param">size_t <b>certLen</b></td><td>The length of the certificate.</td></tr>
            <tr><td class="param">const char * <b>hostName</b></td><td>Reserved for later use, always should be set to nullptr.</td></tr>
            <tr><td class="param">UWebserverPlugin * <b>user</b></td><td>The user to inform the result. This helps to have different UWebserverPlugin instances. If set to nullptr, the same user as passed to IWebserverPluginProvider::Create() will be used (which hovewer is the default user).</td></tr>
        </table>

		<h4>Callbacks</h4>
		On success, an incoming request will lead to a callback of UWebserverPlugin::WebserverPluginSendCertificateResult().<br/>
 		If an error occurres, USocket::SocketShutdown() will be called. Details of that error can be found inside the log, if logging is activated. :<br/>
        <table style="margin-left: 20px">
            <tr><td><b>WSP_ADDRESS_INVALID</b></td><td>The address to connect to the webserver is invalid.</td></tr>
        </table>
    </dd>

    <div class="fnhead">Accept</div>
    <dd>
		If an incomming request should be accepted, one of the IWebserverPlugin::Accept() functions must be called. For each request an instance of one of the following users must be passed (depending on request type):
        <ul>
            <li>UWebserverGet</li>
            <li>UWebserverPost</li>
            <li>UWebserverPut</li>
            <li>UWebserverPassthrough</li>
            <li>UWebserverPropfind</li>
            <li>UWebserverMove</li>
            <li>UWebserverMkCol</li>
            <li>UWebserverCopy</li>
            <li>UWebserverDelete</li>
            <li>UWebserverLock</li>
            <li>UWebserverUnlock</li>
            <li>UWebserverProppatch</li>
            <li>UWebserverOptions</li>
        </ul>
		The application must create a class derived from one of the users above and implement the necessary functions. If passing nullptr instead an instance of one of that classes, the request will be cancleed (which will be
		the same behaviour as calling cancel with WSP_CANCEL_NOT_FOUND).

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param"><i>User instance</i> * <b>user</b></td><td>The instance of one the above users. That user will be responsible to handle the request. If nullptr, the request will be handled with reason WSP_CANCEL_NOT_FOUND.</td></tr>
        </table>

		<h4>Callbacks</h4>
		After calling Accept() with a valid user instance, the *RequestAcceptComplete() callback of the given user will be called (e. G. UWebserverGet::WebserverGetRequestAcceptComplete()). See the documentation for that user classes for more details.

        <h4>Remarks</h4>
        IWebserverPlugin::Accept() must be called inside the UWebserverPlugin::WebserverPluginHttpListenResult() or UWebserverPlugin::WebserverPassthroughListenresult(). If the request should not be accepted, IWebserverPlugin::Cancel() must be called.<br/>
		To accept an incomming Websocket request, IWebserverPlugin::WebsocketAccept() must be called.<br/>
		Calling IWebserverPlugin::Accept() with an instance of one of the user classes that not will correspond to the accept will lead to an assertion.
    </dd>

    <div class="fnhead">WebsocketAccept</div>
    <dd>
		If a websocket request comes in, it can be accepted using the WebsocketAccept() function. (To deny, call Cancel()). When accepting, an instance of a class derived from UWebsocket must be passed. This instance will be responsible for the websocket
		connections. See <a href="UWebsocket">UWebsocket</a> for details. If nullptr will be passed to WebsocketAccept(), the request will be denied in the same way as calling IWebserverPlugin::Cancel().

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">UWebsocketUser * <b>user</b></td><td>The instance of one the users to handle the websocket communication, that will be responsible to handle the request. If nullptr, the request will be denied.</td></tr>
        </table>

		<h4>Callbacks</h4>
		After calling Accept() with a valid user instance, the UWebsocket::WebsocketAcceptComplete callback of that user will be called.

        <h4>Remarks</h4>
        IWebserverPlugin::WebsocketAccept() must be called inside the UWebserverPlugin::WebserverPluginWebsocketListenResult(). If the request should denied, IWebserverPlugin::Cancel() must be called.<br/>
    </dd>

    <div class="fnhead">Cancel</div>
    <dd>
		This function will be used to deny an incomming request.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason why the request had been canceled. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more infos.</td></tr>
        </table>

        <h4>Remarks</h4>
		This function must be called from inside of one of the *ListenResult() functions.<br/>
        Like Accept() (and WebsocketAccept()), Cancel() will be used to deny each type of request, including websocket.<br/>
    </dd>

    <div class="fnhead">Redirect</div>
    <dd>
		An incomming request can not only be accepted or denied, it can also be redireted to an other location. Redirecting using this function is a temporary redirect. That means, that a HTTP conform client will automatically went to the new place, until
		the browser will be started again.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>newDestination</b></td><td>The destination to redirect to. Can be a relative or absolut path. For an absolute path, the value muast start with "http://".</td></tr>
        </table>

        <h4>Remarks</h4>
		Like Accept() and Cancel(), this function must be called inside the *ListenResult() function (e. G. UWebserverPlugin::WebserverPluginHttpListenReuslt()).<br/>
		Redirection is not supported for Websocket requests. Calling IWebserverPlugin::Redirect() for a websocket request will lead to an assertion.
    </dd>

    <div class="fnhead">RequestUserPasswordResult</div>
    <dd>
		When dynamic authentication had ben activated (see HttpListen() above) and the Webserver asks for a users password, IWebserverPlugin::RequestUserPasswordResult() must be called. This funtion can be called outside from
		UWebserverPlugin::WebserverPluginRequestUserPassword(), so reading the password from an other source like a database is possible. Note that the client needs to wailt until the app calls RequestUserPasswordResult().

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">dword <b>connectionID</b></td><td>The ID of the connection authentication request comes from. Must be the same id as received in UWebserverPlugin::WebserverPluginRequestUserPassword(). If the
																	password can not be send directly inside the request function, the application must save the connection id to response later.</td></tr>
            <tr><td class="param">const char * <b>user</b></td><td>The user that requested the authentication. Must be the same as received in UWebserverPlugin::WebserverPluginRequestUserPassword(). If the
																	password can not be send directly inside the request function, the application must save the user name to response later. If the user is denied by the application, user can
																	set to nullptr for the response.</td></tr>
            <tr><td class="param">const char * <b>password</b></td><td>The password for that user. If user is set to nullptr, tha value given to password will be ignored. If password  is set to nullptr, no password will be used for authentication.</td></tr>
        </table>

        <h4>Remarks</h4>
		If the connection id and user name are not the same as passed to UWebserverPlugin::WebserverPluginRequestUserPassword(), the webserver will deny the request (like setting user to nullptr).
    </dd>

    <div class="fnhead">Close</div>
    <dd>
		Closes the IWebserverPlugin instance. The application must wait until UWebserverPlugin::WebserverPluginClose() had been closed with lastUser set to true, before freeing the IWebserverPlugin instance. See <a href="#UWebserverPlugin">UWebserverPlugin</a> for more details.

        <h4>Remarks</h4>
		After closed, each still active user passed to one of the functions that accept an aditional UWebserverPlugin instance, will receife a UWebserverPlugin::WebserverPluginClose() callback. It is guaranteed, that the main user will
		be the last one informed. The lastUser flag helps to identify that case.
    </dd>

	<a name="UWebserverPlugin"><h2>UWebserverPlugin</h2></a>
	<pre><code style="laguage-cpp">class UWebserverPlugin {
public:
    virtual ~UWebserverPlugin() {}

    virtual void WebserverPluginClose(IWebserverPlugin * plugin, wsp_close_reason_t reason, bool lastUser)
    {
        if (lastUser) delete plugin;
    }
    
    virtual void WebserverPluginHttpListenResult(IWebserverPlugin * plugin, ws_request_type_t requestType, char * resourceName, const char * registeredPathForRequest, ulong64 dataSize)
    {
        plugin->Cancel(WSP_CANCEL_NOT_FOUND);
    }

    virtual void WebserverPluginPassthroughListenResult(IWebserverPlugin * plugin, char * resourceName, const char * registeredPathForRequest, ulong64 dataSize)
    {
        plugin->Cancel(WSP_CANCEL_NOT_FOUND);
    }

    virtual void WebserverPluginWebsocketListenResult(IWebserverPlugin * plugin, const char * path, const char * registeredPathForRequest, const char * host)
    {
        plugin->WebsocketAccept(nullptr);
    }

    virtual void WebserverPluginConnected() {}
    virtual void WebserverPluginSendCertificateResult(IWebserverPlugin * plugin, byte * certBuffer) {}
    virtual void WebserverPluginRegisterPathResult(IWebserverPlugin * plugin, const char * pathName, wsp_path_type_t pathType) {}
    virtual void WebserverPluginRequestUserPassword(IWebserverPlugin * plugin, dword connectionID, char * resourceName, const char * registeredPathForRequest, const char * host, const char * user) { ASSERT(false, "UWebserverPlugin::WebserverPluginRequestUserPassword() not implemented!"); }
    virtual void SetAuthConfigResult(const char * path, ws_update_auth_result_t result) {}    
};</code></pre>

	<h3>Overview</h3>
	Each action needed to be redirected to the applicationm the IWebserverPlugin instrance will call one fo the UWebserverPlugin functions. So an application that is going to use the Webserver Plugin must provide a subclass of
	UWebserverPlugin and implement what is needed. UWebserverPlugin is used to handle incomming requests (if not a GET request handled by static files), accept requests and handle some other details.
	
	<h3>Public functions</h3>
	<div class="fnhead">WebserverPluginHttpListenResult</div>
    <dd>
		Will be called after calling IWebserverPlugin::HttpListen() and receiving a HTTP request. The request must be canceld or accepted inside this function. If the function will return without accepting or canceling the
		request, an assertion will be thrown. To accept the request, IWebserverRequest::Accept() must be called, passing an UWebserver* handler instance combining with the request.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPlugin * <b>plugin</b></td><td>The calling IWebserverPlugin instance</td></tr>
            <tr><td class="param">ws_request_type_t <b>requestType</b></td><td>The type of the request. See <a href="#ws_request_type_t">ws_request_type_t</a> for details.</td></tr>
            <tr><td class="param">char * <b>resourceName</b></td><td>The resource requested. The resource can include a relative path, with the given registeredPathForRequest as root. </td></tr>
            <tr><td class="param">char * <b>registeredPathForRequest</b></td><td>The registered path for that request.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The size of the data comming with the request, if the kind of request can deliver data (e. g. POST).</td></tr>
        </table>
		
		<h4>Callbacks</h4>
		If the incomming request had been accepted, the WebserverPluginAcceptComplete of the user passed to accept will be called.

        <h4>Remarks</h4>
		Valid users for an HTTP request to pass to IWebserverPlugin::Accept() are:
        <ul>
            <li>UWebserverGet</li>
            <li>UWebserverPost</li>
            <li>UWebserverPut</li>
            <li>UWebserverPassthrough</li>
            <li>UWebserverPropfind</li>
            <li>UWebserverMove</li>
            <li>UWebserverMkCol</li>
            <li>UWebserverCopy</li>
            <li>UWebserverDelete</li>
            <li>UWebserverLock</li>
            <li>UWebserverUnlock</li>
            <li>UWebserverProppatch</li>
            <li>UWebserverOptions</li>
        </ul>
    </dd>

	<div class="fnhead">WebserverPluginPassthroughListenResult</div>
    <dd>
		Will be called after calling IWebserverPlugin::PassthroughListen() and receiving a passthrough request. The request must be canceld or accepted inside this function. If the function will return without accepting or canceling the
		request, an assertion will be thrown. To accept the request, IWebserverRequest::Accept() must be called, passing an UWebserverPassthrough instance. Note that if the application listens for passthrough, it will be responsible
		to handle the HTTP request by itself.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPlugin * <b>plugin</b></td><td>The calling IWebserverPlugin instance</td></tr>
            <tr><td class="param">char * <b>resourceName</b></td><td>The resource requested. The resource can include a relative path, with the given registeredPathForRequest as root. </td></tr>
            <tr><td class="param">char * <b>registeredPathForRequest</b></td><td>The registered path for that request.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The size of the data comming with the request. This data must be be read with IWebserverPassthrough::Recv() and includes the whole HTTP header of the request.</td></tr>
        </table>
		
		<h4>Callbacks</h4>
		If the incomming request had been accepted, the WebserverPluginAcceptComplete of the user passed to accept will be called.
    </dd>

	<div class="fnhead">WebserverPluginWebsocketListenResult</div>
    <dd>
		Will be called after calling IWebserverPlugin::WebsocketListen() and receiving a websocket request. The request must be canceld or accepted inside this function. If the function will return without accepting or canceling the
		request, an assertion will be thrown. To accept the request, IWebserverRequest::Accept() must be called, passing an UWebsocket instance.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPlugin * <b>plugin</b></td><td>The calling IWebserverPlugin instance</td></tr>
            <tr><td class="param">const char * <b>path</b></td><td>The path for the request. However, even if it is called "path", it can include a filename, too. Depending on what had been passed to IWebserver::WebsocketListen(). </td></tr>
            <tr><td class="param">const char * <b>registeredPathForRequest</b></td><td>The registered path for that request.</td></tr>
            <tr><td class="param">const char * <b>host</b></td><td>The host of the request.</td></tr>
        </table>
		
		<h4>Callbacks</h4>
		If the incomming request had been accepted, the WebserverPluginWebsocketAcceptComplete of the user passed to accept will be called.
    </dd>

	<div class="fnhead">WebserverPluginConnected</div>
    <dd>
		Will be called after calling IWebserverPlugin::Connect() and after the connection had been established. It will be e good idea to call the IWebsocketPlugin::*Listen() after the connection had been established, but
		it can bee called before receiving the WebserverPluginConnected() callback either.
    </dd>

	<div class="fnhead">WebserverPluginClose</div>
    <dd>
		Will be called after the IWebserverPlugin had been closed. Note that when the WebserverPlugin uses the connection (because the websever is down), it is going to reconnect until the connection can be established again. After closing,
		the IWebserverPlugin Instance should be released.
		
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPlugin * <b>plugin</b></td><td>The calling IWebserverPlugin instance</td></tr>
            <tr><td class="param">wsp_close_reason_t <b>reason</b></td><td>The reason why the plugin had been closed. See <a href="#wsp_close_reason_t ">wsp_close_reason_t </a> for more details. </td></tr>
            <tr><td class="param">bool <b>lastUser</b></td><td>If true, the user that receivces that callback is the last user, so that the instance can be deleted.</td></tr>
        </table>
		
		<h4>Remarks</h4>
		Because the IWebserverPlugin::*Listen() function can be called with multiple users, each user given to that functions will receive teh WebserverPluginClose() callback with lastUser set to false. Except the last user which
		is the user given when creating the plugin. This user will receive the callback with lastUser set to true. In that case it is gauranteed, that all other users already had been informed and no more WebserverPluginClose()
		call will be made. So the IWebserverPlugin instance can be deleted. Never delete the instance while lastUser is false!
    </dd>

	<div class="fnhead">WebserverPluginSendCertificateResult</div>
    <dd>
		The IWebserverPlugin can be used to send a certificate to the Webserver, that will be used for TLS connections. After sucessfully sent, this function will be called.
		
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPlugin * <b>plugin</b></td><td>The calling IWebserverPlugin instance</td></tr>
            <tr><td class="param">byte * <b>certBuffer</b></td><td>The buffer with the certificate sent.</td></tr>
        </table>
		
		<h4>Remarks</h4>
		Normally, the AppPlatform Manager will send the certificate to the webserver, so there is no need for an app to use the mechanism to set a certificate.
    </dd>

	<div class="fnhead">WebserverPluginRegisterPathResult</div>
    <dd>
		When calling one of the Listen functions of IWebserverPlugin, the path given to that function will be registerd inside the webserver. This process will lead to the WebserverPlugin RegisterPathResult() call.
		An application can watch to the result of the registration process (if wanted) by implementing that callback function.
		
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPlugin * <b>plugin</b></td><td>The calling IWebserverPlugin instance</td></tr>
            <tr><td class="param">const char * <b>pathName</b></td><td>The registered path name, the same as given to one of the listen functions. </td></tr>
            <tr><td class="param">wsp_path_type_t <b>pathType</b></td><td>The type of the registered path. The value depends on the called listen function. See <a href="#wsp_path_type_t">wsp_path_type_t</a> for more details.</td></tr>
        </table>
    </dd>

	<div class="fnhead">WebserverPluginRequestUserPassword</div>
    <dd>
		The IWebserverPlugin supports two ways for authentication: the static authentication (that is giving the user name and password while listening to the a path), and the dynamic way where the Webserver asks the IWebserverPlugin
		for the user name and password for each request. This will be done with this callback. The user name an password must be returned to the Webserver by calling IWebserverPlugin::RequestUserPasswordResult().
		
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPlugin * <b>plugin</b></td><td>The calling IWebserverPlugin instance</td></tr>
            <tr><td class="param">dword <b>connectionID</b></td><td>The id of the connection that whants to authenticate. This ID must be given (together with the user name) to IWebserverPlugin::RequestUserPasswordResult() for answering the authentication request.</td></tr>
            <tr><td class="param">char * <b>resourceName</b></td><td>The resource the needs to authenticate. The resource can include a relative path, with the given registeredPathForRequest as root. </td></tr>
            <tr><td class="param">const char * <b>registeredPathForRequest</b></td><td>The registered path for the request.</td></tr>
            <tr><td class="param">const char * <b>host</b></td><td>The host that tries to acces the resource.</td></tr>
            <tr><td class="param">const char * <b>user</b></td><td>The user that tries to authenticate. Must be given (together with the connection id) to IWebserverPlugin::RequestUserPasswordResult() for answering the authentication request. </td></tr>
        </table>
		
		<h4>Remarks</h4>
		The authentication request can be responded outside of this function. This comes in handy if e. g. the user information must be read from the database, first. The application only need to take care of sending the correct connection id with the
		user name given for the request.
    </dd>

	<div class="fnhead">SetAuthConfigResult</div>
    <dd>
		Will be called after the webserver has changed the authentication configuration because of a previous call to <a href="#IWebserverPlugin">IWebserverPlugin</a>::SetAuthConfig().
		
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>path</b></td><td>The path the configuration needed to be changed for ("/" for the apps web root). Will always be the same path as used for the previous SetAuthConfig() call.</td></tr>
            <tr><td class="param">ws_update_auth_result_t <b>result</b></td><td>The result of the config change. See the <a href="#ws_update_auth_result_t">ws_update_auth_result_t enum</a> for details.</td></tr>
        </table>
    </dd>
    
	<a name="IWebserverGet"><h2>IWebserverGet</h2></a>
	<pre><code style="laguage-cpp">class IWebserverGet {
public:
    virtual ~IWebserverGet() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual const char * GetETag();
    virtual ulong64 GetRangeCount();
    virtual IWebserverGetRange * GetRange(size_t idx);

    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void SetTransferInfo(wsr_type_t resourceType, ulong64 dataSize, wsr_flags_t flags = WSP_FLAG_NONE, const char * etag = nullptr);
    virtual void SetTransferRange(ulong64 rangeStart, ulong64 rangeEnd);
    virtual void ForceDownloadResponse(const char * fileName = nullptr);
    virtual void Send(void * buffer, size_t len);
    virtual void Close();
};</code></pre>

	<h3>Overview</h3>
	After accepting an incoming GET request, UWebserverGet::WebserverGetRequestAcceptComplete() will be called with the IWebserverGet instance to use to answer the request. The IWebserverGet intercace is all
	that is needed to response the GET request. The instance is only valid for one request, and each request has it's own IWeberverGet instance. After sending the response, the IWebserverGet instance must be closed
	to tell the Webserver, that the response had been completed.
	
	<h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
		Returns the name of the requested resource. That name inclides the path below the registered path the request was for. So if the registered path is "/images" and the request goes to "/images/ui/buttons/ok.png", GetResourceName()
		will return "/ui/buttons/ok.png".

		<h4>Return value</h4>
		The resource requested as const string.
    </dd>
	
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
		Returns the registered path the request was for. So if the registered path is "/images" and the request goes to "/images/ui/buttons/ok.png", GetRegisteredPathForRequest() will return "/images".

		<h4>Return value</h4>
		The registered path of the request as const string.
    </dd>

    <div class="fnhead">GetETag</div>
    <dd>
		Return the ETag, if there is any. ETag will be used for the caching mechanism of the HTTP clients. The static files will send an ETag (which is the MD5 checksum of the file) to help the browser indendicate, whether a file had been changed or not. The
		This also can be done for a dynamic file by setting an etag (which must not be a MD5 checksum) and comparing it with the one send by the browser on further requests.

		<h4>Return value</h4>
		The Etag as const string.
		
		<h4>Remarks</h4>
		The default validity for a file with browser caching enabled is 5 minutes.
    </dd>
	
    <div class="fnhead">GetRangeCount</div>
    <dd>
		If the HTTP client only requests a part of a file, he will send ranges to define what part. GetRangeCount() returns the number of ranges available for that requst. The ranges values will be retunred by GetRange() (see below). The application
		must only return the data for the requested ranges.

		<h4>Return value</h4>
		The number of ranges for the request. If 0, there are no ranges for that request. In that case, the application must return the whole file.
    </dd>
	
    <div class="fnhead">GetRange</div>
    <dd>
		Returns the range with teh given index. See <a href="IWebserverGetRange">IWebserverGetRange</a> for details.
		
		<h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">size_t <b>idx</b></td><td>The index of the range to get, zero based. Must not exceed IWebserverGet::GetRangeCount() - 1.</td></tr>
        </table>

		<h4>Return value</h4>
		An IWebserverGetRange instance holding the range informations.
		
		<h4>Remarks</h4>
		The returned IWebserverGetRange instance is managed by the IWebserverGet instance. The data hold by IWebserverGetRange will be valid until the next time GetRange() will be called. If the range needed to be saved
		for later use, the application must store the data elsewhere.<br/>
		You must not free the IWebserverGetRange instance returned by IWebserverGet.
    </dd>

    <div class="fnhead">Cancel</div>
    <dd>
		Sometimes an application can not know if a request should be accepted or now at the moment, the request leads to a listen result. For that cases, the request can still be cancled inside the UWebserverGet instance
		by calling IWebserverGet::Cancel(). However, this function can also be used to cancel an already started byte transfer for the response. This comes in handy, when there is need to cancel a chunk encoded response or
		even a response with kown content length.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for the cancel. See <a href="wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
		
		<h4>Remarks</h4>
		Cancel() will call Close() after sending the informations to the Webserver.
    </dd>

    <div class="fnhead">SetTransferInfo</div>
    <dd>
		Before responding for a GET request, the type of the request must set first by calling SetTransferInfo().

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_type_t <b>resourceType</b></td><td>The type of the reosurce the application is going to send. Dis should combine with the type of resource requested. The helper functon
																																	<a href="#GetResponseTypeForFileName">GetResponseTypeForFileName</a> can be used to get the right resource type depending on the resource sufix.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The data size of the requests data. If unkown, the application must used chunked encoding by setting dataSize to WS_RESPONSE_CHUNKED.</td></tr>
            <tr><td class="param">wsr_flags_t <b>flags</b></td><td><i>(Default WSP_FLAG_NONE)</i>Optional, additional flags. See <a href="wsr_flags_t ">wsr_flags_t </a> for details.</td></tr>
            <tr><td class="param">const char * <b>etag</b></td><td><i>(Default nullptr)</i> An optional etag used for caching purposed of an HTTP client.</td></tr>
        </table>
		
        <h4>Remarks</h4>
		When passing an etag value, the HTTP clients caching mechanism will be activated.  The default validity for a file with browser caching enabled is 5 minutes. So in that time, the HTTP client won't ask again for the file but loads
		it from it's local cache. The time period is fixed and cannot be changed.		
    </dd>

    <div class="fnhead">SetTransferRange</div>
    <dd>
		When the HTTP client requests a range only, the response must define the range sent.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ulong64 <b>rangeStart</b></td><td>The start of the range.</td></tr>
            <tr><td class="param">ulong64 <b>rangeEnd</b></td><td>The end of the range.</td></tr>
        </table>

        <h4>Remarks</h4>
		The values of rangeStart and rangeEnd depends on the requested range. See <a href="#IWebserverGetRange">IWebserverGetRange</a> for details.
    </dd>

    <div class="fnhead">ForceDownloadResponse</div>
    <dd>
		Generally, when requesting a file with the GET request, the HTTP client will save the file under the requested name. Somethimes there is need to save the file under an other name. This can be realized
		using ForeceDownloadResponse() to set the file name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fileName</b></td><td><i>(Default nullptr)</i> The filename the HTTP client should use. If set to nullptr, the same filename as requested will be used. That's practically the same as
																																not calling ForceDownloadResponse().</td></tr>
        </table>
    </dd>

    <div class="fnhead">Send</div>
    <dd>
		Sends the given data. The number of bytes that will be send must be the same as given to SetTransferInfo() (unless WS_RESPONSE_CHUNKED has passed as dataSize to SetTransferInfo()). If the data the application will send
		exceeds WS_MAX_DATA_SIZE, multiple Send() calls must be used.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>A pointer to the buffer holding the data to send.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>Then umber of bytes to send.</td></tr>
        </table>
		
		<h4>Callbacks</h4>
		After the data had been sent, the UWebserverGet::WebserverGetSendResult() of the user passed to IWenserverPlugin::Accept() will be called.

        <h4>Remarks</h4>
		SendTransferInfo() must be called before calling Send() the first time!<br/>
		Trying to send more than WS_MAX_DATA_SIZE with one send call leads to an assertion.<br/>
		It is highly recommendet send the next data part after receiving UWebserverGet::WebserverPluginSendResult().
    </dd>

    <div class="fnhead">Close</div>
    <dd>
		Closes the IWebserverGet interface and with this also finalizes the response. It should be called after the number of bytes passed to SetTransferInfo() or after the last data part for chunked transfer had been sent. An HTTP client
		will not realize the end of the transfer and still wait for data, until Close() had been called. If the transfer of the response data should be canceled, IWebserverGet::Cancel() need to be called.

		<h4>Callbacks</h4>
		After closing, UWebserverGet::WebserverGetCloseComplete() will be called.
    </dd>

	<a name="IWebserverGetRange"><h2>IWebserverGetRange</h2></a>
	<pre><code style="language-cpp">class IWebserverGetRange {
public:
    IWebserverGetRange() {}
    virtual ~IWebserverGetRange() {}

    enum range_type_t {
        RANGE_NONE       = 0x00,
        RANGE_START_END  = 0x01,
        RANGE_START_ONLY = 0x02,
        RANGE_LAST_BYTES = 0x03
    } rangeType;

    ulong64 start;
    ulong64 end;
};</code></pre>

	<h3>Overview</h3>
	Sometimes, a HTTP client will request only a range of a resource. In that case, one or more range informations can be received from the IWebserverGet instance. That informations will be stored inside a IWebserverGetRange and returned
	to the app. 
	
	<h3>Remarks</h3>
	The applcation must not free an IWebserverGetRange instance received from UWebserverGet::GetRange().
	
	<h3>Public fields</h3>
    <div class="fnhead">start</div>
    <dd>
		The start of the range in bytes. The value depends on the range type.
    </dd>
	
    <div class="fnhead">end</div>
    <dd>
		The end of the range in bytes. The value depends on the range type.
    </dd>
	
    <div class="fnhead">rangeType</div>
    <dd>
		There are different types of ranges defined by this type, which will be one of the vollowing values:
        <table style="margin-left: 20px">
            <tr><td><b>RANGE_NONE</b></td><td>No range defined. This generally is only for initializing purpose and will never show up in an IWebserverGetRange instance retunred by IWebserverGet::GetRange().</td></tr>
            <tr><td><b>RANGE_START_END</b></td><td>The value of start and end are the byte positions where to start and end the transfer inside the resource. If end is out of range of the resource size, the real end position should be used.</td></tr>
            <tr><td><b>RANGE_START_ONLY</b></td><td>The value of start defines the byte position, where to start the transder inside the resource. End will be the rest of data inside the resource.</td></tr>
            <tr><td><b>RANGE_LAST_BYTES</b></td><td>The number of the lst bytes of the resource to transfer. With this, the start position is resource end - number of last bytes.</td></tr>
        </table>
    </dd>

	<a name="UWebserverGet"><h2>UWebserverGet</h2></a>
	<pre><code style="laguage-cpp">class UWebserverGet {
public:
    virtual ~UWebserverGet() {}
        
    virtual void WebserverGetRequestAcceptComplete(IWebserverGet * const webserverGet);
    virtual void WebserverGetSendResult(IWebserverGet * const webserverGet);
    virtual void WebserverGetCloseComplete(IWebserverGet * const webserverGet);
};</code></pre>

	<h3>Overview</h3>
    This is the user for a GET request handler. The application needs to implement the functions below.
    
    <h3>Remarks</h3>
    The request can be responded asynchronously. But the application must take care sending the same number of bytes as defined before start sending
    data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the browser
    (our whatever client) will wait for incomming data or at least recognize a transfer error. 
    See <a href="#IWebserverGet">IWebserverGet</a> for more details.<br/>Note that the application is responsible for releasing the UWebserverGet instance!
	
    <h3>Public functions</h3>
    <div class="fnhead">WebserverGetRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming GET request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverGet instance for later use.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverGet * const <b>webserverGet</b></td><td>The calling IWebserverGet instance.</td></tr>
        </table>
    </dd>

    <div class="fnhead">WebserverGetSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverGet::Send() had been send to the client by the webserver itself.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverGet * const <b>webserverGet</b></td><td>The calling IWebserverGet instance.</td></tr>
        </table>
    </dd>

    <div class="fnhead">WebserverGetCloseComplete</div>
    <dd>
        Will be called after the connection had been called. This can be a result of calling IWebserverGet::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverGet instance. 

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverGet * const <b>webserverGet</b></td><td>The calling IWebserverGet instance.</td></tr>
        </table>
    </dd>

	<a name="IWebserverPost"><h2>IWebserverPost</h2></a>
	<pre><code style="laguage-cpp">class IWebserverPost {
public:
    virtual ~IWebserverPost() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual ulong64 GetDataSize();
    virtual bool DataIsChunkEncoded();

    virtual void SetTransferInfo(wsr_type_t resourceType, ulong64 dataSize, wsr_flags_t flags = WSP_FLAG_NONE, const char * etag = nullptr);
    virtual void ForceDownloadResponse(const char * fileName = nullptr);
    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void Send(void * buffer, size_t len);
    virtual void Recv(void * buffer = nullptr, size_t len = 0);
    virtual void Close();
};</code></pre>

	<h3>Overview</h3>
	This handler is for handling POST requests. Note that for now the webserver only supports POST requests wich one set of data. If there is a form posted, the application itself need to divide the form data.
	
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
		<h4>Return value</h4>
		The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>

    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
		<h4>Return value</h4>
		The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>

    <div class="fnhead">GetDataSize</div>
    <dd>
		<h4>Return value</h4>
		The number of bytes sent with the POST request. The data can be received by calling IWebserverPost::Recv(). If the data is chunke encoded, the size is unkown and 0 will be returned.
    </dd>

    <div class="fnhead">DataIsChunkEncoded</div>
    <dd>
		<h4>Return value</h4>
		True if the data to receive is chunk encoded, else false.
    </dd>

    <div class="fnhead">SetTransferInfo</div>
    <dd>
        Before responding for a POST request, the type of the request must set first by calling SetTransferInfo().

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr>
                <td class="param">wsr_type_t <b>resourceType</b></td>
                <td>
                    The type of the reosurce the application is going to send. Dis should combine with the type of resource requested. The helper functon
                    <a href="#GetResponseTypeForFileName">GetResponseTypeForFileName</a> can be used to get the right resource type depending on the resource sufix.
                </td>
            </tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The data size of the requests data. If unkown, the application must used chunked encoding by setting dataSize to WS_RESPONSE_CHUNKED.</td></tr>
            <tr><td class="param">wsr_flags_t <b>flags</b></td><td><i>(Default WSP_FLAG_NONE)</i>Optional, additional flags. See <a href="wsr_flags_t ">wsr_flags_t </a> for details.</td></tr>
            <tr><td class="param">const char * <b>etag</b></td><td><i>(Default nullptr)</i> An optional etag used for caching purposed of an HTTP client.</td></tr>
        </table>

        <h4>Remarks</h4>
        When passing an etag value, the HTTP clients caching mechanism will be activated.  The default validity for a file with browser caching enabled is 5 minutes. So in that time, the HTTP client won't ask again for the file but loads
        it from it's local cache. The time period is fixed and cannot be changed.
    </dd>

    <div class="fnhead">ForceDownloadResponse</div>
    <dd>
        Generally, when requesting a file with the POST request, the HTTP client will save the file under the requested name. Somethimes there is need to save the file under an other name. This can be realized
        using ForeceDownloadResponse() to set the file name.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr>
                <td class="param">const char * <b>fileName</b></td>
                <td>
                    <i>(Default nullptr)</i> The filename the HTTP client should use. If set to nullptr, the same filename as requested will be used. That's practically the same as
                    not calling ForceDownloadResponse().
                </td>
            </tr>
        </table>
    </dd>

    <div class="fnhead">Cancel</div>
    <dd>
		Cancels the POST request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
		
		<h4>Callbacks</h4>
		Because Cancel() also closes the transfer, UWebserverPost::WebserverPostCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverPost intance,
		because it will no longer be used.
		
        <h4>Remarks</h4>
		Cancel will automatically close the request. So there is no need to call close, too.<br/>
		The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>

    <div class="fnhead">Send</div>
    <dd>
		Sends the give data to the client. Before calling Send(), SetTransferInfo() must be called. And if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetTransferInfo().

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
		
		<h4>Callbacks</h4>
		After the data had been sent, UWebserverPost::WebserverPostSendResult() of the user passed to IWenserverPlugin::Accept() will be called.

        <h4>Remarks</h4>
		The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
	
    <div class="fnhead">Recv</div>
    <dd>
		Receives data sent with the request.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td><i>(Default: nullptr)</i> The buffer to store the data to. Must be big enough to be able to receive len bytes of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td><i>(Default: 0)</i> The number of bytes to receive. If buffer is not nullptr, len must be > 0.</td></tr>
        </table>
		
		<h4>Return value</h4>
		<h4>Callbacks</h4>
		After the data had been read, UWebserverPost::WebserverPostRecvResult() of the user passed to IWebserverPlugin::Accept() will be called. If all data had been read, the WebserverPostRecvResult() will be called with nullptr as buffer and 0 as len.<br/>
		If buffer is nullptr, UWebserverPost::WebserverPostRecvBuffer() will be called to request the buffer to store the data to.

        <h4>Remarks</h4>
		If buffer is nullptr, the IWebserverPost will ask the application for a buffer of a given size when reading the data. This will be realized by the WebserverPostRecvBuffer() callback.<br/>
		If the data to read is chunk encoded, Recv() should be called (recommended without passing a buffer), until RecvResult() will called with nullptr as buffer and 0 as len. However, this also works for non chunk encoded transfer.<br/>
		The maximum data to read per Recv() call is WS_MAX_DATA_SIZE.
    </dd>

    <div class="fnhead">Close</div>
    <dd>
		Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.

		<h4>Callbacks</h4>
		After the connection had been closed, UWebserverPost::WebserverPostCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverPost intance,
		because it will no longer be used.
    </dd>

	<a name="UWebserverPost"><h2>UWebserverPost</h2></a>
	<pre><code style="laguage-cpp">class UWebserverPost {
public:
    virtual ~UWebserverPost() {}
        
    virtual void WebserverPostRequestAcceptComplete(IWebserverPost * const webserverPost);
    virtual void WebserverPostSendResult(IWebserverPost * const webserverPost) {}
    virtual void WebserverPostRecvResult(IWebserverPost * const webserverPost, void * buffer, size_t len);
    virtual void * WebserverPostRecvBuffer(size_t len) { return nullptr; }
    virtual void WebserverPostCloseComplete(IWebserverPost * const webserverPost);
};</code></pre>

	<h3>Overview</h3>
    This is the user for a POST request handler. The application needs to implement the functions below. The UWebserverPost instance must be
    used to read the data posted and to send a response, if needed.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverPost">IWebserverPost</a> for more details.<br/>Note that the application is responsible for releasing the UWebserverPost instance!
	
    <h3>Public functions</h3>
    <div class="fnhead">WebserverPostRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming POST request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverPost  instance for later use.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPost * const <b>webserverPost</b></td><td>The calling IWebserverPost instance.</td></tr>
        </table>
    </dd>

    <div class="fnhead">WebserverPostSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverPost::Send() had been send to the client by the webserver itself.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPost * const <b>webserverPost</b></td><td>The calling IWebserverPost instance.</td></tr>
        </table>
    </dd>

    <div class="fnhead">WebserverPostRecvResult</div>
    <dd>
		Will be called after receiving data, initiated through IWebserverPost::Recv().

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPost * const <b>webserverPost</b></td><td>The calling IWebserverPost instance.</td></tr>
            <tr><td class="param">void  * <b>buffer</b></td><td>The buffer holding the received data. Will be the same as passed to
                                                                IWebserverPost::Recv() or returned by UWebserverPost::WebserverPostRecvBuffer().
                                                                Will be nullptr if there is no more data to receive.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number of bytes received.</td></tr>
        </table>

        <h4>Remarks</h4>
        Because the number of bytes to recveive will be unkown if the data to receive is chunk encoded, a WebserverPostRecvResult() callback
        will be called with buffer nullptr and len 0. This remarks the end of the transfer. It also works for streamed data transfer. So it isn't
        necessary to count the number of bytes received (except the application has futher usage for that informations like realizing a progressbar).
    </dd>

    <div class="fnhead">WebserverPostRecvBuffer</div>
    <dd>
        If IWebserverPost::Recv() will be called with buffer = nullptr, the IWebserverPost handler will call this function to request a buffer to store
        the data. 

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">size_t <b>len</b></td><td>The numbert of bytes to transfer. The returned buffer must provide at least that size.</td></tr>
        </table>
		
        <h4>Return value</h4>
        The buffer to store the data to. Must not be nullptr.
    </dd>

    <div class="fnhead">WebserverPostCloseComplete</div>
    <dd>
        Will be called after the connection had been called. This can be a result of calling IWebserverPost::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverPost instance. 

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPost * const <b>webserverPost</b></td><td>The calling IWebserverPost instance.</td></tr>
        </table>
    </dd>

    <a name="IWebserverPut"><h2>IWebserverPut</h2></a>
    <pre><code style="laguage-cpp">class IWebserverPut {
public:
    virtual ~IWebserverPut() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual ulong64 GetDataSize();
    virtual bool DataIsChunkEncoded();
    virtual const char * GetHeaderFieldValue(const char * fieldName);

    virtual void SetResultCode(ws_webdav_result_t result, ulong64 dataSize = 0);

    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void Send(void * buffer, size_t len);
    virtual void Recv(void * buffer = nullptr, size_t len = 0);
    virtual void Close();
};</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling PUT requests.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>
    
    <div class="fnhead">GetDataSize</div>
    <dd>
        <h4>Return value</h4>
        The number of bytes sent with the PUT request. The data can be received by calling IWebserverPut::Recv(). If the data is chunke encoded, the size is unkown and 0 will be returned.
    </dd>
    
    <div class="fnhead">DataIsChunkEncoded</div>
    <dd>
        <h4>Return value</h4>
        True if the data to receive is chunk encoded, else false.
    </dd>
    
    <div class="fnhead">GetHeaderFieldValue</div>
    <dd>
        Returns the value of the given header filed sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fieldName</b></td><td>The name of the header field.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The value assigned to the header field or nullptr, if the requested header field doesn't exist.
    </dd>
    
    <div class="fnhead">SetResultCode</div>
    <dd>
        Set the result code and optionally the data size for the requests answer.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>result</b></td><td>The result code to set. See <a href=#ws_webdav_result_t>ws_webdav_result_t</a> for details.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The number of data that will be send. Pass WS_RESPONSE_CHUNKED to enabled chunk enconded transfer.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    <div class="fnhead">Cancel</div>
    <dd>
        Cancels the PUT request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        Because Cancel() also closes the transfer, UWebserverPut::WebserverPutCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverPut instance,
        because it will no longer be used.
        
        <h4>Remarks</h4>
        Cancel will automatically close the request. So there is no need to call close, too.<br/>
        The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverPut::WebserverPutSendResult() of the user passed to IWebserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Before calling Send(), SetResultCode() must be called. And, if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetResultCode().
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Recv</div>
    <dd>
        Receives data sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td><i>(Default: nullptr)</i> The buffer to store the data to. Must be big enough to be able to receive len bytes of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td><i>(Default: 0)</i> The number of bytes to receive. If buffer is not nullptr, len must be > 0.</td></tr>
        </table>
        
        <h4>Return value</h4>
        <h4>Callbacks</h4>
        After the data had been read, UWebserverPut::WebserverPutRecvResult() of the user passed to IWebserverPlugin::Accept() will be called. If all data had been read, the WebserverPutRecvResult() will be called with nullptr as buffer and 0 as len.<br/>
        If buffer is nullptr, UWebserverPut::WebserverPutRecvBuffer() will be called to request the buffer to store the data to.
    
        <h4>Remarks</h4>
        If the data to read is chunk encoded, Recv() should be called (recommended without passing a buffer), until RecvResult() will called with nullptr as buffer and 0 as len. However, this also works for non chunk encoded transfer.<br/>
        The maximum data to read per Recv() call is WS_MAX_DATA_SIZE.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverPut::WebserverPutCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverPut intance,
        because it will no longer be used.
    </dd>

    <a name="UWebserverPut"><h2>UWebserverPut</h2></a>
    <pre><code style="laguage-cpp">class UWebserverPut {
public:
    virtual ~UWebserverPut() {}
            
    virtual void WebserverPutRequestAcceptComplete(IWebserverPut * const webserverPut);
    virtual void WebserverPutSendResult(IWebserverPut * const webserverPut);
    virtual void WebserverPutRecvResult(IWebserverPut * const webserverPut, void * buffer, size_t len);
    virtual void * WebserverPutRecvBuffer(size_t len) { return nullptr; }
    virtual void WebserverPutCloseComplete(IWebserverPut * const webserverPut);
};</code></pre>
    
    <h3>Overview</h3>
    This is the user for a PUT request handler. The application needs to implement the functions below. The UWebserverPut instance must be
    used to read the data send with the request, if needed.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverPut">IWebserverPut</a> for more details.<br/>Note that the application is responsible for releasing the UWebserverPut instance!
    
    <h3>Public functions</h3>
    <div class="fnhead">WebserverPutRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming PUT request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverPut  instance for later use.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPut * const <b>webserverPut</b></td><td>The calling IWebserverPut instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverPutSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverPut::Send() had been send to the client by the webserver itself.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPut * const <b>webserverPut</b></td><td>The calling IWebserverPut instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverPutRecvResult</div>
    <dd>
        Will be called after receiving data, initiated through IWebserverPut::Recv().
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPut * const <b>webserverPut</b></td><td>The calling IWebserverPut instance.</td></tr>
            <tr><td class="param">void  * <b>buffer</b></td><td>The buffer holding the received data. Will be the same as passed to
                                                                IWebserverPut::Recv() or returned by UWebserverPut::WebserverPutRecvBuffer().
                                                                Will be nullptr if there is no more data to receive.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number of bytes received.</td></tr>
        </table>
    
        <h4>Remarks</h4>
        Because the number of bytes to recveive will be unkown if the data to receive is chunk encoded, a WebserverPutRecvResult() callback
        will be called with buffer nullptr and len 0. This remarks the end of the transfer. It also works for streamed data transfer. So it isn't
        necessary to count the number of bytes received (except the application has futher usage for that informations like realizing a progressbar).
    </dd>
    
    <div class="fnhead">WebserverPutRecvBuffer</div>
    <dd>
        If IWebserverPut::Recv() will be called with buffer = nullptr, the IWebserverPut handler will call this function to request a buffer to store
        the data. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">size_t <b>len</b></td><td>The numbert of bytes to transfer. The returned buffer must provide at least that size.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The buffer to store the data to. Must not be nullptr.
    </dd>
    
    <div class="fnhead">WebserverPutCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverPut::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverPut instance. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPut * const <b>webserverPut</b></td><td>The calling IWebserverPut instance.</td></tr>
        </table>
    </dd>
    
    <a name="IWebserverPropfind"><h2>IWebserverPropfind</h2></a>
    <pre><code style="laguage-cpp">class IWebserverPropfind {
public:
    virtual ~IWebserverPropfind() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual ulong64 GetDataSize();
    virtual bool DataIsChunkEncoded();
    virtual const char * GetHeaderFieldValue(const char * fieldName);

    virtual void SetResultCode(ws_webdav_result_t result, ulong64 dataSize = 0);
    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void Recv(void * buffer = nullptr, size_t len = 0);
    virtual void Send(void * buffer, size_t len);
    virtual void Close();
};</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling PROPFIND requests.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>
    
    <div class="fnhead">GetDataSize</div>
    <dd>
        <h4>Return value</h4>
        The number of bytes sent with the PROPFIND request. The data can be received by calling IWebserverPropfind::Recv(). If the data is chunke encoded, the size is unkown and 0 will be returned.
    </dd>
    
    <div class="fnhead">DataIsChunkEncoded</div>
    <dd>
        <h4>Return value</h4>
        True if the data to receive is chunk encoded, else false.
    </dd>
    
    <div class="fnhead">GetHeaderFieldValue</div>
    <dd>
        Returns the value of the given header filed sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fieldName</b></td><td>The name of the header field.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The value assigned to the header field or nullptr, if the requested header field doesn't exist.
    </dd>
    
    <div class="fnhead">SetResultCode</div>
    <dd>
        Set the result code and optionally the data size for the requests answer.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>result</b></td><td>The result code to set. See <a href=#ws_webdav_result_t>ws_webdav_result_t</a> for details.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The number of data that will be send. Pass WS_RESPONSE_CHUNKED to enabled chunk enconded transfer.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    <div class="fnhead">Cancel</div>
    <dd>
        Cancels the PROPFIND request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        Because Cancel() also closes the transfer, UWebserverPropfind::WebserverPropfindCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverPropfind instance,
        because it will no longer be used.
        
        <h4>Remarks</h4>
        Cancel will automatically close the request. So there is no need to call close, too.<br/>
        The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverPropfind::WebserverPropfindSendResult() of the user passed to IWebserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Before calling Send(), SetResultCode() must be called. And, if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetResultCode().
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Recv</div>
    <dd>
        Receives data sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td><i>(Default: nullptr)</i> The buffer to store the data to. Must be big enough to be able to receive len bytes of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td><i>(Default: 0)</i> The number of bytes to receive. If buffer is not nullptr, len must be > 0.</td></tr>
        </table>
        
        <h4>Return value</h4>
        <h4>Callbacks</h4>
        After the data had been read, UWebserverPropfind::WebserverPropfindRecvResult() of the user passed to IWebserverPlugin::Accept() will be called. If all data had been read, the WebserverPropfindRecvResult() will be called with nullptr as buffer and 0 as len.<br/>
        If buffer is nullptr, UWebserverPropfind::WebserverPropfindRecvBuffer() will be called to request the buffer to store the data to.
    
        <h4>Remarks</h4>
        If the data to read is chunk encoded, Recv() should be called (recommended without passing a buffer), until RecvResult() will called with nullptr as buffer and 0 as len. However, this also works for non chunk encoded transfer.<br/>
        The maximum data to read per Recv() call is WS_MAX_DATA_SIZE.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverPropfind::WebserverPropfindCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverPropfind intance,
        because it will no longer be used.
    </dd>
    
    <a name="UWebserverPropfind"><h2>UWebserverPropfind</h2></a>
    <pre><code style="laguage-cpp">class UWebserverPropfind {
public:
    virtual ~UWebserverPropfind() {};
    virtual void WebserverPropfindRequestAcceptComplete(IWebserverPropfind * const webserverPropfind);
    virtual void WebserverPropfindSendResult(IWebserverPropfind * const webserverPropfind);
    virtual void WebserverPropfindRecvResult(IWebserverPropfind * const webserverPropfind, void * buffer, size_t len);
    virtual void * WebserverPropfindRecvBuffer(size_t len)
    {
        return nullptr;
    }
        
    virtual void WebserverPropfindCloseComplete(IWebserverPropfind * const webserverPropfind);
};</code></pre>
    
    <h3>Overview</h3>
    This is the user for a PROPFIND request handler. The application needs to implement the functions below. The UWebserverPropfind instance must be
    used to read the data send with the request, if needed.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverPropfind">IWebserverPropfind</a> for more details.<br/>Note that the application is responsible for releasing the UWebserverPropfind instance!
    
    <h3>Public functions</h3>
    <div class="fnhead">WebserverPropfindRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming PROPFIND request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverPropfind  instance for later use.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPropfind * const <b>webserverPropfind</b></td><td>The calling IWebserverPropfind instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverPropfindSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverPropfind::Send() had been send to the client by the webserver itself.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPropfind * const <b>webserverPropfind</b></td><td>The calling IWebserverPropfind instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverPropfindRecvResult</div>
    <dd>
        Will be called after receiving data, initiated through IWebserverPropfind::Recv().
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPropfind * const <b>webserverPropfind</b></td><td>The calling IWebserverPropfind instance.</td></tr>
            <tr><td class="param">void  * <b>buffer</b></td><td>The buffer holding the received data. Will be the same as passed to
                                                                IWebserverPropfind::Recv() or returned by UWebserverPropfind::WebserverPropfindRecvBuffer().
                                                                Will be nullptr if there is no more data to receive.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number of bytes received.</td></tr>
        </table>
    
        <h4>Remarks</h4>
        Because the number of bytes to recveive will be unkown if the data to receive is chunk encoded, a WebserverPropfindRecvResult() callback
        will be called with buffer nullptr and len 0. This remarks the end of the transfer. It also works for streamed data transfer. So it isn't
        necessary to count the number of bytes received (except the application has futher usage for that informations like realizing a progressbar).
    </dd>
    
    <div class="fnhead">WebserverPropfindRecvBuffer</div>
    <dd>
        If IWebserverPropfind::Recv() will be called with buffer = nullptr, the IWebserverPropfind handler will call this function to request a buffer to store
        the data. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">size_t <b>len</b></td><td>The numbert of bytes to transfer. The returned buffer must provide at least that size.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The buffer to store the data to. Must not be nullptr.
    </dd>
    
    <div class="fnhead">WebserverPropfindCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverPropfind::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverPropfind instance. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverPropfind * const <b>webserverPropfind</b></td><td>The calling IWebserverPropfind instance.</td></tr>
        </table>
    </dd>
    
    <a name="IWebserverMove"><h2>IWebserverMove</h2></a>
    <pre><code style="laguage-cpp">class IWebserverMove {
public:
    virtual ~IWebserverMove() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual const char * GetHeaderFieldValue(const char * fieldName);

    virtual void SetResultCode(ws_webdav_result_t result, ulong64 dataSize = 0);
    virtual void SetLocation(const char * location);
    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void Send(void * buffer, size_t len);
    virtual void Close();
};</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling MOVE requests.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>
    
    <div class="fnhead">GetHeaderFieldValue</div>
    <dd>
        Returns the value of the given header filed sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fieldName</b></td><td>The name of the header field.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The value assigned to the header field or nullptr, if the requested header field doesn't exist.
    </dd>
    
    <div class="fnhead">SetResultCode</div>
    <dd>
        Set the result code and optionally the data size for the requests answer.
    
        <h4>Remarks</h4>
        Note that SetLocation() must be called before sending data or closing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>result</b></td><td>The result code to set. See <a href=#ws_webdav_result_t>ws_webdav_result_t</a> for details.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The number of data that will be send. Pass WS_RESPONSE_CHUNKED to enabled chunk enconded transfer.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    <div class="fnhead">SetLocation</div>
    <dd>
        Set the location the data / file had been moved to.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>location</b></td><td>The new location of the data / file.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    
    <div class="fnhead">Cancel</div>
    <dd>
        Cancels the MOVE request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        Because Cancel() also closes the transfer, UWebserverMove::WebserverMoveCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverMove instance,
        because it will no longer be used.
        
        <h4>Remarks</h4>
        Cancel will automatically close the request. So there is no need to call close, too.<br/>
        The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverMove::WebserverMoveSendResult() of the user passed to IWebserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Before calling Send(), SetResultCode() must be called. And, if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetResultCode().
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverMove::WebserverMoveCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverMove intance,
        because it will no longer be used.
    </dd>
    
    <a name="UWebserverMove"><h2>UWebserverMove</h2></a>
    <pre><code style="laguage-cpp">class UWebserverMove {
public:
    virtual ~UWebserverMove() {};
    virtual void WebserverMoveRequestAcceptComplete(IWebserverMove * const webserverMove);
    virtual void WebserverMoveSendResult(IWebserverMove * const webserverMove);
    virtual void WebserverMoveCloseComplete(IWebserverMove * const webserverMove);
};</code></pre>
    
    <h3>Overview</h3>
    This is the user for a MOVE request handler. The application needs to implement the functions below.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverMove">IWebserverMove</a> for more details.<br/>
    Note that the application is responsible for releasing the UWebserverMove instance!
    
    <h3>Public functions</h3>
    <div class="fnhead">WebserverMoveRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming MOVE request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverMove  instance for later use.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverMove * const <b>webserverMove</b></td><td>The calling IWebserverMove instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverMoveSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverMove::Send() had been send to the client by the webserver itself.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverMove * const <b>webserverMove</b></td><td>The calling IWebserverMove instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverMoveCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverMove::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverMove instance. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverMove * const <b>webserverMove</b></td><td>The calling IWebserverMove instance.</td></tr>
        </table>
    </dd>
    
    <a name="IWebserverMkCol"><h2>IWebserverMkCol</h2></a>
    <pre><code style="laguage-cpp">class IWebserverMkCol {
public:
    virtual ~IWebserverMkCol() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual const char * GetHeaderFieldValue(const char * fieldName);

    virtual void SetResultCode(ws_webdav_result_t result, ulong64 dataSize = 0);
    virtual void SetLocation(const char * location);
    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void Send(void * buffer, size_t len);
    virtual void Close();
};</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling MKCOL requests.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>
    
    <div class="fnhead">GetHeaderFieldValue</div>
    <dd>
        Returns the value of the given header filed sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fieldName</b></td><td>The name of the header field.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The value assigned to the header field or nullptr, if the requested header field doesn't exist.
    </dd>
    
    <div class="fnhead">SetResultCode</div>
    <dd>
        Set the result code and optionally the data size for the requests answer.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>result</b></td><td>The result code to set. See <a href=#ws_webdav_result_t>ws_webdav_result_t</a> for details.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The number of data that will be send. Pass WS_RESPONSE_CHUNKED to enabled chunk enconded transfer.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    <div class="fnhead">SetLocation</div>
    <dd>
        Set the location the created collection.
    
        <h4>Remarks</h4>
        Note that SetLocation() must be called before sending data or closing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>location</b></td><td>The location of the created collection.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    
    <div class="fnhead">Cancel</div>
    <dd>
        Cancels the MKCOL request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        Because Cancel() also closes the transfer, UWebserverMkCol::WebserverMkColCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverMkCol instance,
        because it will no longer be used.
        
        <h4>Remarks</h4>
        Cancel will automatically close the request. So there is no need to call close, too.<br/>
        The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverMkCol::WebserverMkColSendResult() of the user passed to IWebserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Before calling Send(), SetResultCode() must be called. And, if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetResultCode().
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverMkCol::WebserverMkColCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverMkCol intance,
        because it will no longer be used.
    </dd>
    
    <a name="UWebserverMkCol"><h2>UWebserverMkCol</h2></a>
    <pre><code style="laguage-cpp">class UWebserverMkCol {
public:
    virtual ~UWebserverMkCol() {};
    virtual void WebserverMkColRequestAcceptComplete(IWebserverMkCol * const webserverMkCol);
    virtual void WebserverMkColSendResult(IWebserverMkCol * const webserverMkCol);
    virtual void WebserverMkColCloseComplete(IWebserverMkCol * const webserverMkCol);
};</code></pre>
    
    <h3>Overview</h3>
    This is the user for a MKCOL request handler. The application needs to implement the functions below.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverMkCol">IWebserverMkCol</a> for more details.<br/>
    Note that the application is responsible for releasing the UWebserverMkCol instance!
    
    <h3>Public functions</h3>
    <div class="fnhead">WebserverMkColRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming MKCOL request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverMkCol  instance for later use.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverMkCol * const <b>webserverMkCol</b></td><td>The calling IWebserverMkCol instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverMkColSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverMkCol::Send() had been send to the client by the webserver itself.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverMkCol * const <b>webserverMkCol</b></td><td>The calling IWebserverMkCol instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverMkColCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverMkCol::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverMkCol instance. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverMkCol * const <b>webserverMkCol</b></td><td>The calling IWebserverMkCol instance.</td></tr>
        </table>
    </dd>
    
    <a name="IWebserverCopy"><h2>IWebserverCopy</h2></a>
    <pre><code style="laguage-cpp">class IWebserverCopy {
public:
    virtual ~IWebserverCopy() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual const char * GetHeaderFieldValue(const char * fieldName);

    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void SetResultCode(ws_webdav_result_t result, ulong64 dataSize = 0);
    virtual void Send(void * buffer, size_t len);
    virtual void Close();
};</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling COPY requests.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>
    
    <div class="fnhead">GetHeaderFieldValue</div>
    <dd>
        Returns the value of the given header filed sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fieldName</b></td><td>The name of the header field.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The value assigned to the header field or nullptr, if the requested header field doesn't exist.
    </dd>
    
    <div class="fnhead">SetResultCode</div>
    <dd>
        Set the result code and optionally the data size for the requests answer.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>result</b></td><td>The result code to set. See <a href=#ws_webdav_result_t>ws_webdav_result_t</a> for details.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The number of data that will be send. Pass WS_RESPONSE_CHUNKED to enabled chunk enconded transfer.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    <div class="fnhead">Cancel</div>
    <dd>
        Cancels the COPY request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        Because Cancel() also closes the transfer, UWebserverCopy::WebserverCopyCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverCopy instance,
        because it will no longer be used.
        
        <h4>Remarks</h4>
        Cancel will automatically close the request. So there is no need to call close, too.<br/>
        The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverCopy::WebserverCopySendResult() of the user passed to IWebserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Before calling Send(), SetResultCode() must be called. And, if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetResultCode().
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverCopy::WebserverCopyCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverCopy intance,
        because it will no longer be used.
    </dd>
    
    <a name="UWebserverCopy"><h2>UWebserverCopy</h2></a>
    <pre><code style="laguage-cpp">class UWebserverCopy {
public:
    virtual ~UWebserverCopy() {};
    virtual void WebserverCopyRequestAcceptComplete(IWebserverCopy * const webserverCopy);
    virtual void WebserverCopySendResult(IWebserverCopy * const webserverCopy);
    virtual void WebserverCopyCloseComplete(IWebserverCopy * const webserverCopy);
};</code></pre>
    
    <h3>Overview</h3>
    This is the user for a COPY request handler. The application needs to implement the functions below.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverCopy">IWebserverCopy</a> for more details.<br/>
    Note that the application is responsible for releasing the UWebserverCopy instance!
    
    <h3>Public functions</h3>
    <div class="fnhead">WebserverCopyRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming COPY request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverCopy  instance for later use.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverCopy * const <b>webserverCopy</b></td><td>The calling IWebserverCopy instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverCopySendResult</div>
    <dd>
        Will be called after a data package send by IWebserverCopy::Send() had been send to the client by the webserver itself.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverCopy * const <b>webserverCopy</b></td><td>The calling IWebserverCopy instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverCopyCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverCopy::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverCopy instance. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverCopy * const <b>webserverCopy</b></td><td>The calling IWebserverCopy instance.</td></tr>
        </table>
    </dd>
    
    <a name="IWebserverDelete"><h2>IWebserverDelete</h2></a>
    <pre><code style="laguage-cpp">class IWebserverDelete {
public:
    virtual ~IWebserverDelete() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual const char * GetHeaderFieldValue(const char * fieldName);

    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void SetResultCode(ws_webdav_result_t result, ulong64 dataSize = 0);
    virtual void Send(void * buffer, size_t len);
    virtual void Close();
};</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling DELETE requests.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>
    
    <div class="fnhead">GetHeaderFieldValue</div>
    <dd>
        Returns the value of the given header filed sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fieldName</b></td><td>The name of the header field.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The value assigned to the header field or nullptr, if the requested header field doesn't exist.
    </dd>
    
    <div class="fnhead">SetResultCode</div>
    <dd>
        Set the result code and optionally the data size for the requests answer.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>result</b></td><td>The result code to set. See <a href=#ws_webdav_result_t>ws_webdav_result_t</a> for details.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The number of data that will be send. Pass WS_RESPONSE_CHUNKED to enabled chunk enconded transfer.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    <div class="fnhead">Cancel</div>
    <dd>
        Cancels the DELETE request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        Because Cancel() also closes the transfer, UWebserverDelete::WebserverDeleteCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverDelete instance,
        because it will no longer be used.
        
        <h4>Remarks</h4>
        Cancel will automatically close the request. So there is no need to call close, too.<br/>
        The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverDelete::WebserverDeleteSendResult() of the user passed to IWebserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Before calling Send(), SetResultCode() must be called. And, if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetResultCode().
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverDelete::WebserverDeleteCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverDelete intance,
        because it will no longer be used.
    </dd>
    
    <a name="UWebserverDelete"><h2>UWebserverDelete</h2></a>
    <pre><code style="laguage-cpp">class UWebserverDelete {
public:
    virtual ~UWebserverDelete() {};
    virtual void WebserverDeleteRequestAcceptComplete(IWebserverDelete * const webserverDelete);
    virtual void WebserverDeleteSendResult(IWebserverDelete * const webserverDelete);
    virtual void WebserverDeleteCloseComplete(IWebserverDelete * const webserverDelete);
};</code></pre>
    
    <h3>Overview</h3>
    This is the user for a DELETE request handler. The application needs to implement the functions below.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverDelete">IWebserverDelete</a> for more details.<br/>
    Note that the application is responsible for releasing the UWebserverDelete instance!
    
    <h3>Public functions</h3>
    <div class="fnhead">WebserverDeleteRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming DELETE request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverDelete  instance for later use.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverDelete * const <b>webserverDelete</b></td><td>The calling IWebserverDelete instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverDeleteSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverDelete::Send() had been send to the client by the webserver itself.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverDelete * const <b>webserverDelete</b></td><td>The calling IWebserverDelete instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverDeleteCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverDelete::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverDelete instance. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverDelete * const <b>webserverDelete</b></td><td>The calling IWebserverDelete instance.</td></tr>
        </table>
    </dd>

    <a name="IWebserverLock"><h2>IWebserverLock</h2></a>
    <pre><code style="laguage-cpp">class IWebserverLock {
public:
    virtual ~IWebserverLock() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual const char * GetHeaderFieldValue(const char * fieldName);

    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void SetResultCode(ws_webdav_result_t result, size_t dataSize = 0);
    virtual void Recv(void * buffer = nullptr, size_t len = 0);
    virtual void Send(void * buffer, size_t len);
    virtual void Close();
};</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling LOCK requests.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>
    
    <div class="fnhead">GetHeaderFieldValue</div>
    <dd>
        Returns the value of the given header filed sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fieldName</b></td><td>The name of the header field.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The value assigned to the header field or nullptr, if the requested header field doesn't exist.
    </dd>
    
    <div class="fnhead">SetResultCode</div>
    <dd>
        Set the result code and optionally the data size for the requests answer.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>result</b></td><td>The result code to set. See <a href=#ws_webdav_result_t>ws_webdav_result_t</a> for details.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The number of data that will be send. Pass WS_RESPONSE_CHUNKED to enabled chunk enconded transfer.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    <div class="fnhead">Cancel</div>
    <dd>
        Cancels the LOCK request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        Because Cancel() also closes the transfer, UWebserverLock::WebserverLockCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverLock instance,
        because it will no longer be used.
        
        <h4>Remarks</h4>
        Cancel will automatically close the request. So there is no need to call close, too.<br/>
        The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverLock::WebserverLockSendResult() of the user passed to IWebserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Before calling Send(), SetResultCode() must be called. And, if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetResultCode().
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Recv</div>
    <dd>
        Receives data sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td><i>(Default: nullptr)</i> The buffer to store the data to. Must be big enough to be able to receive len bytes of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td><i>(Default: 0)</i> The number of bytes to receive. If buffer is not nullptr, len must be > 0.</td></tr>
        </table>
        
        <h4>Return value</h4>
        <h4>Callbacks</h4>
        After the data had been read, UWebserverLock::WebserverLockRecvResult() of the user passed to IWebserverPlugin::Accept() will be called. If all data had been read, the WebserverLockRecvResult() will be called with nullptr as buffer and 0 as len.<br/>
        If buffer is nullptr, UWebserverLock::WebserverLockRecvBuffer() will be called to request the buffer to store the data to.
    
        <h4>Remarks</h4>
        If the data to read is chunk encoded, Recv() should be called (recommended without passing a buffer), until RecvResult() will called with nullptr as buffer and 0 as len. However, this also works for non chunk encoded transfer.<br/>
        The maximum data to read per Recv() call is WS_MAX_DATA_SIZE.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverLock::WebserverLockCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverLock intance,
        because it will no longer be used.
    </dd>
    
    <a name="UWebserverLock"><h2>UWebserverLock</h2></a>
    <pre><code style="laguage-cpp">class UWebserverLock {
public:
    virtual ~UWebserverLock() {};
    virtual void WebserverLockRequestAcceptComplete(IWebserverLock * const webserverLock);
    virtual void WebserverLockSendResult(IWebserverLock * const webserverLock);
    virtual void WebserverLockRecvResult(IWebserverLock * const webserverLock, void * buffer, size_t len);
    virtual void * WebserverLockRecvBuffer(size_t len)
    {
        return nullptr;
    }
    virtual void WebserverLockCloseComplete(IWebserverLock * const webserverLock);
};</code></pre>
    
    <h3>Overview</h3>
    This is the user for a LOCK request handler. The application needs to implement the functions below. The UWebserverLock instance must be
    used to read the data send with the request, if needed.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverLock">IWebserverLock</a> for more details.<br/>Note that the application is responsible for releasing the UWebserverLock instance!
    
    <h3>Public functions</h3>
    <div class="fnhead">WebserverLockRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming LOCK request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverLock  instance for later use.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverLock * const <b>webserverLock</b></td><td>The calling IWebserverLock instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverLockSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverLock::Send() had been send to the client by the webserver itself.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverLock * const <b>webserverLock</b></td><td>The calling IWebserverLock instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverLockRecvResult</div>
    <dd>
        Will be called after receiving data, initiated through IWebserverLock::Recv().
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverLock * const <b>webserverLock</b></td><td>The calling IWebserverLock instance.</td></tr>
            <tr><td class="param">void  * <b>buffer</b></td><td>The buffer holding the received data. Will be the same as passed to
                                                                IWebserverLock::Recv() or returned by UWebserverLock::WebserverLockRecvBuffer().
                                                                Will be nullptr if there is no more data to receive.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number of bytes received.</td></tr>
        </table>
    
        <h4>Remarks</h4>
        Because the number of bytes to recveive will be unkown if the data to receive is chunk encoded, a WebserverLockRecvResult() callback
        will be called with buffer nullptr and len 0. This remarks the end of the transfer. It also works for streamed data transfer. So it isn't
        necessary to count the number of bytes received (except the application has futher usage for that informations like realizing a progressbar).
    </dd>
    
    <div class="fnhead">WebserverLockRecvBuffer</div>
    <dd>
        If IWebserverLock::Recv() will be called with buffer = nullptr, the IWebserverLock handler will call this function to request a buffer to store
        the data. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">size_t <b>len</b></td><td>The numbert of bytes to transfer. The returned buffer must provide at least that size.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The buffer to store the data to. Must not be nullptr.
    </dd>
    
    <div class="fnhead">WebserverLockCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverLock::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverLock instance. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverLock * const <b>webserverLock</b></td><td>The calling IWebserverLock instance.</td></tr>
        </table>
    </dd>
    
    <a name="IWebserverUnlock"><h2>IWebserverUnlock</h2></a>
    <pre><code style="laguage-cpp">class IWebserverUnlock {
public:
    virtual ~IWebserverUnlock() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual const char * GetHeaderFieldValue(const char * fieldName);

    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void SetResultCode(ws_webdav_result_t result, ulong64 dataSize = 0);
    virtual void Send(void * buffer, size_t len);
    virtual void Close();
};</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling UNLOCK requests.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>
    
    <div class="fnhead">GetHeaderFieldValue</div>
    <dd>
        Returns the value of the given header filed sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fieldName</b></td><td>The name of the header field.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The value assigned to the header field or nullptr, if the requested header field doesn't exist.
    </dd>
    
    <div class="fnhead">SetResultCode</div>
    <dd>
        Set the result code and optionally the data size for the requests answer.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>result</b></td><td>The result code to set. See <a href=#ws_webdav_result_t>ws_webdav_result_t</a> for details.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The number of data that will be send. Pass WS_RESPONSE_CHUNKED to enabled chunk enconded transfer.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    <div class="fnhead">Cancel</div>
    <dd>
        Cancels the UNLOCK request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        Because Cancel() also closes the transfer, UWebserverUnlock::WebserverUnlockCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverUnlock instance,
        because it will no longer be used.
        
        <h4>Remarks</h4>
        Cancel will automatically close the request. So there is no need to call close, too.<br/>
        The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverUnlock::WebserverUnlockSendResult() of the user passed to IWebserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Before calling Send(), SetResultCode() must be called. And, if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetResultCode().
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverUnlock::WebserverUnlockCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverUnlock intance,
        because it will no longer be used.
    </dd>
    
    <a name="UWebserverUnlock"><h2>UWebserverUnlock</h2></a>
    <pre><code style="laguage-cpp">class UWebserverUnlock {
public:
    virtual ~UWebserverUnlock() {};
    virtual void WebserverUnlockRequestAcceptComplete(IWebserverUnlock * const webserverUnlock);
    virtual void WebserverUnlockSendResult(IWebserverUnlock * const webserverUnlock);
    virtual void WebserverUnlockCloseComplete(IWebserverUnlock * const webserverUnlock);
};</code></pre>
    
    <h3>Overview</h3>
    This is the user for a UNLOCK request handler. The application needs to implement the functions below.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverUnlock">IWebserverUnlock</a> for more details.<br/>Note that the application is responsible for releasing the UWebserverUnlock instance!
    
    <h3>Public functions</h3>
    <div class="fnhead">WebserverUnlockRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming UNLOCK request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverUnlock  instance for later use.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverUnlock * const <b>webserverUnlock</b></td><td>The calling IWebserverUnlock instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverUnlockSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverUnlock::Send() had been send to the client by the webserver itself.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverUnlock * const <b>webserverUnlock</b></td><td>The calling IWebserverUnlock instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverUnlockCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverUnlock::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverUnlock instance. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverUnlock * const <b>webserverUnlock</b></td><td>The calling IWebserverUnlock instance.</td></tr>
        </table>
    </dd>
    
    <a name="IWebserverProppatch"><h2>IWebserverProppatch</h2></a>
    <pre><code style="laguage-cpp">class IWebserverProppatch {
public:
    virtual ~IWebserverProppatch() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();
    virtual const char * GetHeaderFieldValue(const char * fieldName);

    virtual void Cancel(wsr_cancel_type_t reason);
    virtual void SetResultCode(ws_webdav_result_t result, ulong64 dataSize = 0);
    virtual void Recv(void * buffer = nullptr, size_t len = 0);
    virtual void Send(void * buffer, size_t len);
    virtual void Close();
};</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling PROPPATCH requests.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>
    
    <div class="fnhead">GetHeaderFieldValue</div>
    <dd>
        Returns the value of the given header filed sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">const char * <b>fieldName</b></td><td>The name of the header field.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The value assigned to the header field or nullptr, if the requested header field doesn't exist.
    </dd>
    
    <div class="fnhead">SetResultCode</div>
    <dd>
        Set the result code and optionally the data size for the requests answer.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">ws_webdav_result_t <b>result</b></td><td>The result code to set. See <a href=#ws_webdav_result_t>ws_webdav_result_t</a> for details.</td></tr>
            <tr><td class="param">ulong64 <b>dataSize</b></td><td>The number of data that will be send. Pass WS_RESPONSE_CHUNKED to enabled chunk enconded transfer.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetResultCode() must be called before sending data or, in case that no data will be send, before closing the request.<br/>
        The application must send the exact number of bytes using Send(), as given to SetTransferInfo(). If not, the HTTP client may be waiting for ever or ending up in an HTTP parsing error.<br/>
        In chunk encoded mode, the application simply can send data as long as needed. When calling Close(), the chunk encoded transfer will be finalized.
    </dd>
    
    <div class="fnhead">Cancel</div>
    <dd>
        Cancels the PROPPATCH request. If the application already started to send data, the transfare will be canceled. If not, calling Cancel() will be the same as calling IWebserverPlugin::Cancel() when receiveing the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">wsr_cancel_type_t <b>reason</b></td><td>The reason for canceling the request. See <a href="#wsr_cancel_type_t">wsr_cancel_type_t</a> for more details.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        Because Cancel() also closes the transfer, UWebserverProppatch::WebserverProppatchCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverProppatch instance,
        because it will no longer be used.
        
        <h4>Remarks</h4>
        Cancel will automatically close the request. So there is no need to call close, too.<br/>
        The reason only will be of interest if the application not already started to send a response. If already started, the reason will be ignored.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverProppatch::WebserverProppatchSendResult() of the user passed to IWebserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Before calling Send(), SetResultCode() must be called. And, if not called to enabled chunk encoded transfer, the application had to send the number of bytes as given to SetResultCode().
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send, the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Recv</div>
    <dd>
        Receives data sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td><i>(Default: nullptr)</i> The buffer to store the data to. Must be big enough to be able to receive len bytes of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td><i>(Default: 0)</i> The number of bytes to receive. If buffer is not nullptr, len must be > 0.</td></tr>
        </table>
        
        <h4>Return value</h4>
        <h4>Callbacks</h4>
        After the data had been read, UWebserverProppatch::WebserverProppatchRecvResult() of the user passed to IWebserverPlugin::Accept() will be called. If all data had been read, the WebserverProppatchRecvResult() will be called with nullptr as buffer and 0 as len.<br/>
        If buffer is nullptr, UWebserverProppatch::WebserverProppatchRecvBuffer() will be called to request the buffer to store the data to.
    
        <h4>Remarks</h4>
        If the data to read is chunk encoded, Recv() should be called (recommended without passing a buffer), until RecvResult() will called with nullptr as buffer and 0 as len. However, this also works for non chunk encoded transfer.<br/>
        The maximum data to read per Recv() call is WS_MAX_DATA_SIZE.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverProppatch::WebserverProppatchCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverProppatch intance,
        because it will no longer be used.
    </dd>
    
    <a name="UWebserverProppatch"><h2>UWebserverProppatch</h2></a>
    <pre><code style="laguage-cpp">class UWebserverProppatch {
public:
    virtual ~UWebserverProppatch() {};
    virtual void WebserverProppatchRequestAcceptComplete(IWebserverProppatch * const webserverProppatch);
    virtual void WebserverProppatchSendResult(IWebserverProppatch * const webserverProppatch);
    virtual void WebserverProppatchRecvResult(IWebserverProppatch * const webserverProppatch, void * buffer, size_t len);
    virtual void * WebserverProppatchRecvBuffer(size_t len)
    {
        return nullptr;
    }
    virtual void WebserverProppatchCloseComplete(IWebserverProppatch * const webserverProppatch);
};</code></pre>
    
    <h3>Overview</h3>
    This is the user for a PROPPATCH request handler. The application needs to implement the functions below. The UWebserverProppatch instance must be
    used to read the data send with the request, if needed.
    
    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverProppatch">IWebserverProppatch</a> for more details.<br/>Note that the application is responsible for releasing the UWebserverProppatch instance!
    
    <h3>Public functions</h3>
    <div class="fnhead">WebserverProppatchRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming PROPPATCH request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverProppatch  instance for later use.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverProppatch * const <b>webserverProppatch</b></td><td>The calling IWebserverProppatch instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverProppatchSendResult</div>
    <dd>
        Will be called after a data package send by IWebserverProppatch::Send() had been send to the client by the webserver itself.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverProppatch * const <b>webserverProppatch</b></td><td>The calling IWebserverProppatch instance.</td></tr>
        </table>
    </dd>
    
    <div class="fnhead">WebserverProppatchRecvResult</div>
    <dd>
        Will be called after receiving data, initiated through IWebserverProppatch::Recv().
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverProppatch * const <b>webserverProppatch</b></td><td>The calling IWebserverProppatch instance.</td></tr>
            <tr><td class="param">void  * <b>buffer</b></td><td>The buffer holding the received data. Will be the same as passed to
                                                                IWebserverProppatch::Recv() or returned by UWebserverProppatch::WebserverProppatchRecvBuffer().
                                                                Will be nullptr if there is no more data to receive.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number of bytes received.</td></tr>
        </table>
    
        <h4>Remarks</h4>
        Because the number of bytes to recveive will be unkown if the data to receive is chunk encoded, a WebserverProppatchRecvResult() callback
        will be called with buffer nullptr and len 0. This remarks the end of the transfer. It also works for streamed data transfer. So it isn't
        necessary to count the number of bytes received (except the application has futher usage for that informations like realizing a progressbar).
    </dd>
    
    <div class="fnhead">WebserverProppatchRecvBuffer</div>
    <dd>
        If IWebserverProppatch::Recv() will be called with buffer = nullptr, the IWebserverProppatch handler will call this function to request a buffer to store
        the data. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">size_t <b>len</b></td><td>The numbert of bytes to transfer. The returned buffer must provide at least that size.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The buffer to store the data to. Must not be nullptr.
    </dd>
    
    <div class="fnhead">WebserverProppatchCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverProppatch::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverProppatch instance. 
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverProppatch * const <b>webserverProppatch</b></td><td>The calling IWebserverProppatch instance.</td></tr>
        </table>
    </dd>

    <a name="IWebserverOptions"><h2>IWebserverOptions</h2></a>
    <pre><code style="laguage-cpp">class IWebserverOptions {
public:
    virtual ~IWebserverOptions() {}

    virtual const char * GetResourceName();
    virtual const char * GetRegisteredPathForRequest();

    virtual void SetSupportedRequests(dword requestList);
    virtual void Close();
};</code></pre>

    <h3>Overview</h3>
    This handler is for handling OPTIONS requests.

    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as resourceName.
    </dd>

    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginHttpListenResult() as registeredPathForRequest.
    </dd>

    <div class="fnhead">SetSupportedRequests</div>
    <dd>
        Set the bitfield of supported requests.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">dword <b>requestList</b></td><td>Bitfield as dword with the supported webdav options. You should use the <a href=#ws_request_type_t>ws_request_type_t</a> constants to build up the list.</td></tr>
        </table>
        
        <h4>Remarks</h4>
        SetSupportedRequests() must be called before closing the request.
    </dd>

    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This also finalizes a chunk encoded response, so that the client will receive the information that all data had been transfered.

        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverOptions::WebserverOptionsCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebserverOptions intance,
        because it will no longer be used.
    </dd>

    <a name="UWebserverOptions"><h2>UWebserverOptions</h2></a>
    <pre><code style="laguage-cpp">class UWebserverOptions {
public:
    virtual ~UWebserverOptions() {}
    virtual void WebserverOptionsRequestAcceptComplete(IWebserverOptions * const webserverOptions)
    {
        webserverOptions->SetSupportedRequests(WS_REQUEST_GET | WS_REQUEST_POST | WS_REQUEST_PUT |
                                               WS_REQUEST_PROPFIND | WS_REQUEST_MOVE | WS_REQUEST_COPY |
                                               WS_REQUEST_MKCOL | WS_REQUEST_DELETE | WS_REQUEST_OPTIONS |
                                               WS_REQUEST_LOCK | WS_REQUEST_UNLOCK | WS_REQUEST_PROPPATCH);
        webserverOptions->Close();
    }

    virtual void WebserverOptionsCloseComplete(IWebserverOptions * const webserverOptions);
};</code></pre>

    <h3>Overview</h3>
    This is the user for a OPTIONS request handler. The application needs to implement the functions below.

    <h3>Remarks</h3>
    If sending a response, it can (and should) be done asynchronously. But the application must take care sending the same number of bytes as defined before
    start sending data (if using streamed transfer) and closing the connection. Also the correct datatype and transfer info must be set before. If not, the
    browser (our whatever client) will wait for incomming data or at least recognize a transfer error.
    See <a href="#IWebserverOptions">IWebserverOptions</a> for more details.<br/>Note that the application is responsible for releasing the UWebserverOptions instance!

    <h3>Public functions</h3>
    <div class="fnhead">WebserverOptionsRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming OPTIONS request. This will be the correct
        place to start answering the request. A derived class need to save the pointer of the given IWebserverOptions  instance for later use.

        <h4>remarks</h4>
        Note that the default implementation accepts all webdav request supported by the IWebserverPlugin and closes the request.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverOptions * const <b>webserverOptions</b></td><td>The calling IWebserverOptions instance.</td></tr>
        </table>
    </dd>

    <div class="fnhead">WebserverOptionsCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebserverOptions::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebserverOptions instance. 

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebserverOptions * const <b>webserverOptions</b></td><td>The calling IWebserverOptions instance.</td></tr>
        </table>
    </dd>

    <a name="IWebsocket"><h2>IWebsocket</h2></a>
    <pre><code style="laguage-cpp">class IWebsocket {
public:
    virtual ~IWebsocket() {}

    virtual const char * GetHost();
    virtual const char * GetPath();
    virtual bool IsSysClientAuthenticated();
    virtual bool IsLocalHost();

    virtual void Send(const void * buffer, size_t len, bool text = true);
    virtual void Recv(void * buf = nullptr, size_t len = 0);
    virtual void Close();
};</code></pre>

    <h3>Overview</h3>
    This handler is for handling websocket requests. To get websocket requests the app must call IWebserverPlugin::WebsocketListen() must be called. An incomming websocket request will lead to the
    UWebserverPlugin::WebserverPluginWebsocketListenResult() callback. See <a href=IWebserverPlugin>IWebserverPlugin</a> and <a href=UWebserverPlugin>UWebserverPlugin</a> for details.

    <h3>Public functions</h3>
    <div class="fnhead">GetHost</div>
    <dd>
        <h4>Remarks</h4>
        For websocket each request comes with the host that sends the request. Because that is a header value that can be manipulated, this information should not be used for security relevant things.

        <h4>Return value</h4>
        The host of the request.
    </dd>

    <div class="fnhead">GetPath</div>
    <dd>
        <h4>Return value</h4>
        The requested websocket path relative to the root passed to IWebserverPlugin::WebsocketListen().
    </dd>

    <div class="fnhead">IsSysClientAuthenticated</div>
    <dd>
        Returns the information, if a localhost connection between the AppManager and the Webserver is authenticated. Generally there is no need to use that function in your app.

        <h4>Return value</h4>
        True, if authenticated, else false.
    </dd>

    <div class="fnhead">IsLocalHost</div>
    <dd>
        Can be called if there the app needs to know if the connection is a local host connection or not.

        <h4>Return value</h4>
        True if localhost, else false.
    </dd>

    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
            <tr><td class="param">bool <b>text</b></td><td><i>(Default true)</i>If ture, the type of the send data is text, else it is binary data.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebsocket::WebsocketSendResult() of the user passed to IWebserverPlugin::Accept() will be called.

        <h4>Remarks</h4>
        The IWebserverPlugin and the webserver of the AppPlatform wont't make a difference between binary or text data. But a calling webserver client maybe will do it. So it will be a good idea
        to set the text flag to false if sending binary data.<br/>
        The maximum size of data that can be send at once is WS_MAX_DATA_SIZE.
    </dd>

    <div class="fnhead">Recv</div>
    <dd>
        Receives data sent with the request.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td><i>(Default: nullptr)</i> The buffer to store the data to. Must be big enough to be able to receive len bytes of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td><i>(Default: 0)</i> The number of bytes to receive. If buffer is not nullptr, len must be > 0.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been read, UWebsocket::WebsocketRecvResult() of the user passed to IWebserverPlugin::Accept() will be called.<br/>

        <h4>Remarks</h4>
        If called with a buffer an length, the callback will be called after receiving the amount of bytes given to Recv(). If the amount of bytes is unkown, Recv() should be called without a length and buffer.<br/>
        The maximum size of data that can be received at once is WS_MAX_DATA_SIZE.
    </dd>

    <div class="fnhead">Close</div>
    <dd>
        Closes the websocket connection.

        <h4>Callbacks</h4>
        After the connection had been closed, UWebsocket::WebsocketCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This is the right place to delete the IWebsocket intance,
        because it will no longer be used.
    </dd>

    <a name="UWebsocket"><h2>UWebsocket</h2></a>
    <pre><code style="laguage-cpp">class UWebsocket {
public:
    virtual ~UWebsocket() {}
    virtual void WebsocketAcceptComplete(class IWebsocket * websocket);
    virtual void WebsocketSendResult(class IWebsocket * websocket);
    virtual void WebsocketRecvResult(class IWebsocket * websocket, void * buffer, size_t len, bool text, bool isFragmented);
    virtual void * WebsocketRecvBuffer(size_t len) { return nullptr; }
    virtual void WebsocketCloseComplete(class IWebsocket * websocket, ws_close_reason_t reason);
};</code></pre>

    <h3>Overview</h3>
    This is the user for a Websocket request handler. The application needs to implement the functions below to realize websocket communication.

    <h3>Public functions</h3>
    <div class="fnhead">WebsocketRequestAcceptComplete</div>
    <dd>
        Will be called from the IWebserverPlugin Instance after the application accepts an incoming Websocket request. A derived class need to
        save the pointer of the given IWebsocket  instance for later use.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebsocket * const <b>websocket</b></td><td>The calling IWebsocket instance.</td></tr>
        </table>
    </dd>

    <div class="fnhead">WebsocketSendResult</div>
    <dd>
        Will be called after a data package send by IWebsocket::Send() had been send to the client by the webserver itself.

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebsocket * const <b>websocket</b></td><td>The calling IWebsocket instance.</td></tr>
        </table>
    </dd>

    <div class="fnhead">WebsocketRecvResult</div>
    <dd>
        Will be called after receiving data, initiated through IWebsocket::Recv().

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebsocket * const <b>websocket</b></td><td>The calling IWebsocket instance.</td></tr>
            <tr><td class="param">void  * <b>buffer</b></td><td>The buffer holding the received data. Will be the same as passed to
                                                                IWebsocket::Recv() or returned by UWebsocket::WebsocketRecvBuffer().</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number of bytes received.</td></tr>
        </table>
    </dd>

    <div class="fnhead">WebsocketRecvBuffer</div>
    <dd>
        If IWebsocket::Recv() will be called with buffer = nullptr, the IWebsocket handler will call this function to request a buffer to store
        the data. 

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">size_t <b>len</b></td><td>The numbert of bytes to transfer. The returned buffer must provide at least that size.</td></tr>
        </table>
        
        <h4>Return value</h4>
        The buffer to store the data to. Must not be nullptr.
    </dd>

    <div class="fnhead">WebsocketCloseComplete</div>
    <dd>
        Will be called after the connection had been closed. This can be a result of calling IWebsocket::Close() or because of a close
        initiated by the client. This function is the right place to clean up and release the UWebsocket instance. 

        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">IWebsocket * const <b>websocket</b></td><td>The calling IWebsocket instance.</td></tr>
        </table>
    </dd>

    <a name="IWebserverPassthrough"><h2>IWebserverPassthrough</h2></a>
    <pre><code style="laguage-cpp">class IWebserverPassthrough {
    public:
        virtual ~IWebserverPassthrough() {}
            
        virtual const char * GetResourceName();
        virtual const char * GetRegisteredPathForRequest();
        virtual bool IsEncryptedConnection();
            
        virtual void Send(void * buffer, size_t size);
        virtual void Recv(void * buffer = nullptr, size_t len = 0);
        virtual void Close();
    };</code></pre>
    
    <h3>Overview</h3>
    This handler is for handling Passthrough requests.
    
    <h3>Remarks</h3>
    The passthrough handler has a special role. Instead of the others, the webserver doesn't make anything for passthrough requests. Like the name suggests,
    the raw communication will be passed through to the application. That means, that the application is responsible for handling the HTML protocoll, which
    includes parsing and creating of a correct header. So generally there is no need to implement passthrough functionality to our application. On the other
    hand it can help to create apps with proxy functionality.<br/>
    To receive passthrough requests, the application must call IWebserverPlugin::PassthroughListen(). An incomming request will call the
    UWebserverPlugin::WebserverPassthroughListenResult(). See <a href=IWebserverPlugin>IWebserverPlugin</a> and <a href=UWebserverPlugin>UWebserverPlugin</a>
    for details.
    
    <h3>Public functions</h3>
    <div class="fnhead">GetResourceName</div>
    <dd>
        <h4>Return value</h4>
        The name of the resource for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginPassthroughListenResult() as resourceName.
    </dd>
    
    <div class="fnhead">GetRegisteredPathForRequest</div>
    <dd>
        <h4>Return value</h4>
        The name of the registered path for that request. The value returned is the same as passed to UWebserverPlugin::WebserverPluginPassthroughListenResult() as
        registeredPathForRequest.
    </dd>
    
    <div class="fnhead">IsEncryptedConnection</div>
    <dd>
        Can be called to determine, if the connection is encrypted or not (wich is the case if the client uses https://).
        
        <h4>Return value</h4>
        True, if the connection is encrypted, else false.

        <h4>Remarks</h4>
        The encryption is the only thing that still will be handled by the webserver. So even if IsEncryptedConnection() returns true, the application don't need to
        decrypt the data or encrypt the response.
    </dd>
    
    <div class="fnhead">Send</div>
    <dd>
        Sends the give data to the client.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td>The pointer to the buffer with the data to send. Must hold at least len byte of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td>The number bytes to send.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been sent, UWebserverPassthrough::WebserverPassthroughSendResult() of the user passed to IWenserverPlugin::Accept() will be called.
    
        <h4>Remarks</h4>
        Because of the resposebility the application has of handling the HTTP protocoll, the first part sent must be a valid http header.<br/>
        The number of bytes to send must not exceed WS_MAX_DATA_SIZE, or an assertion will be thrown. If more than WS_MAX_DATA_SIZE need to be send,
        the application must call Send() multiple times.
    </dd>
    
    <div class="fnhead">Recv</div>
    <dd>
        Receives data sent with the request.
    
        <h4>Parameters</h4>
        <table style="margin-left:-12px">
            <tr><td class="param">void * <b>buffer</b></td><td><i>(Default: nullptr)</i> The buffer to store the data to. Must be big enough to be able to receive len bytes of data.</td></tr>
            <tr><td class="param">size_t <b>len</b></td><td><i>(Default: 0)</i> The number of bytes to receive. If buffer is not nullptr, len must be > 0.</td></tr>
        </table>
        
        <h4>Callbacks</h4>
        After the data had been read, UWebserverPassthrough::WebserverPassthroughRecvResult() of the user passed to IWebserverPlugin::Accept() will be called. If all data had
        been read, the WebserverPassthroughRecvResult() will be called with nullptr as buffer and 0 as len.<br/>
        If buffer is nullptr, UWebserverPassthrough::WebserverPassthroughRecvBuffer() will be called to request the buffer to store the data to.
    
        <h4>Remarks</h4>
        If buffer is nullptr, the IWebserverPassthrough will ask the application for a buffer of a given size when reading the data. This will be realized by the
        WebserverPassthroughRecvBuffer() callback.<br/>
        Because of the nature of passthrough, the number of bytes to receive is unkown (at least until the HTML header had been read completley and the data will not be
        send chunk encoded). So it will be a good idea, to call Recv() withouth parameters to have some kind of partitial read.<br/>
        The maximum data to read per Recv() call is WS_MAX_DATA_SIZE.
    </dd>
    
    <div class="fnhead">Close</div>
    <dd>
        Closes the request. This tells the webserver to close the socket connection, too.
    
        <h4>Callbacks</h4>
        After the connection had been closed, UWebserverPassthrough::WebserverPassthroughCloseComplete() of the user passed to IWebserverPlugin::Accept() will be called. This
        is the right place to delete the IWebserverPassthrough intance, because it will no longer be used.
    </dd>

    <a name="UWebserverPassthrough"><h2>UWebserverPassthrough</h2></a>
    <pre><code style="laguage-cpp">class UWebserverPassthrough {
public:
    virtual ~UWebserverPassthrough() {}

    virtual void WebserverPassthroughRequestAcceptComplete(IWebserverPassthrough * const webserverPassthrough);
    virtual void WebserverPassthroughSendResult(IWebserverPassthrough * const webserverPassthrough);
    virtual void WebserverPassthroughRecvResult(IWebserverPassthrough * const webserverPassthrough, void * buffer, size_t len);
    virtual void * WebserverPassthroughRecvBuffer(size_t len) { return nullptr; }
    virtual void WebserverPassthroughCloseComplete(IWebserverPassthrough * const webserverPassthrough);
};</code></pre>

<h3>Overview</h3>
This is the user for a Passthrough request handler. The application needs to implement the functions below.

<h3>Remarks</h3>
Note that the application is responsible for releasing the UWebserverPassthrough instance!

<h3>Public functions</h3>
<div class="fnhead">WebserverPassthroughRequestAcceptComplete</div>
<dd>
    Will be called from the IWebserverPlugin Instance after the application accepts an incoming Passthrough request. A derived class need to save
    the pointer of the given IWebserverPassthrough instance for later use.

    <h4>Parameters</h4>
    <table style="margin-left:-12px">
        <tr><td class="param">IWebserverPassthrough * const <b>webserverPassthrough</b></td><td>The calling IWebserverPassthrough instance.</td></tr>
    </table>
</dd>

<div class="fnhead">WebserverPassthroughSendResult</div>
<dd>
    Will be called after a data package send by IWebserverPassthrough::Send() had been send to the client by the webserver itself.

    <h4>Parameters</h4>
    <table style="margin-left:-12px">
        <tr><td class="param">IWebserverPassthrough * const <b>webserverPassthrough</b></td><td>The calling IWebserverPassthrough instance.</td></tr>
    </table>
</dd>

<div class="fnhead">WebserverPassthroughRecvResult</div>
<dd>
    Will be called after receiving data, initiated through IWebserverPassthrough::Recv().

    <h4>Parameters</h4>
    <table style="margin-left:-12px">
        <tr><td class="param">IWebserverPassthrough * const <b>webserverPassthrough</b></td><td>The calling IWebserverPassthrough instance.</td></tr>
        <tr><td class="param">void  * <b>buffer</b></td><td>The buffer holding the received data. Will be the same as passed to
                                                            IWebserverPassthrough::Recv() or returned by UWebserverPassthrough::WebserverPassthroughRecvBuffer().</td></tr>
        <tr><td class="param">size_t <b>len</b></td><td>The number of bytes received.</td></tr>
    </table>
</dd>

<div class="fnhead">WebserverPassthroughRecvBuffer</div>
<dd>
    If IWebserverPassthrough::Recv() will be called with buffer = nullptr, the IWebserverPassthrough handler will call this function to request a buffer to store
    the data. 

    <h4>Parameters</h4>
    <table style="margin-left:-12px">
        <tr><td class="param">size_t <b>len</b></td><td>The numbert of bytes to transfer. The returned buffer must provide at least that size.</td></tr>
    </table>
    
    <h4>Return value</h4>
    The buffer to store the data to. Must not be nullptr.
</dd>

<div class="fnhead">WebserverPassthroughCloseComplete</div>
<dd>
    Will be called after the connection had been called. This can be a result of calling IWebserverPassthrough::Close() or because of a close
    initiated by the client. This function is the right place to clean up and release the UWebserverPassthrough instance. 

    <h4>Parameters</h4>
    <table style="margin-left:-12px">
        <tr><td class="param">IWebserverPassthrough * const <b>webserverPassthrough</b></td><td>The calling IWebserverPassthrough instance.</td></tr>
    </table>
</dd>


<h1>Data types</h1>
<h2>Defines / Statics</h2>
<table style="margin-left: 20px">
    <tr><td><a name="WS_MAX_PATH_LENGTH"><b>WS_MAX_PATH_LENGTH</b></td><td>The maximum length for a path to register using one of the listen functions of IWebserverPlugin.</td></tr>
    <tr><td><a name="WS_MAX_DATA_SIZE"><b>WS_MAX_DATA_SIZE</b></td><td>The maximum data size one Send() or Recv() call can transfer.</td></tr>
    <tr><td><a name="WS_RESPONSE_CHUNKED"><b>WS_RESPONSE_CHUNKED</b></td><td>Flag to define that a response should be sent to the client chunk encoded.</td></tr>
</table>

<h2><a name="wsr_cancel_type_t">wsr_cancel_type_t</a></h2>
<pre><code style="laguage-cpp">typedef enum {
    // Everything from 0 to 15 will be internal types
    WSP_CANCEL_NOT_FOUND = 0x10,
    WSP_CANCEL_BAD_REQUEST,
    WSP_CANCEL_UNAVAILABLE,
    WSP_CANCEL_MISSING_LENGTH,
    WSP_CANCEL_STREAM,
    WSP_CANCEL_ACCESS_DENIED,
    WSP_CANCEL_INTERNAL_ERROR
} wsr_cancel_type_t;</code></pre>

<h3>Overview</h3>
These types will be used to cancel a request. The request can be canceled anytime from the moment the request comes in until
the request will be closed. Canceling a request will also close the request and let the webserver close the connection to the client.
The resposne the webserver sends to the client depends on the values below passed to the Cancel() function of IWebserverPlugin (to cancel
the incomming request) or of the request handler itself (to cancel an accepted request).

<h3>Values</h3>
<table style="margin-left: 20px">
    <tr><td><b>WSP_CANCEL_NOT_FOUND</b></td><td>The requested resource could not be found. Will send a HTTP 404 response to the client.</td></tr>
    <tr><td><b>WSP_CANCEL_BAD_REQUEST</b></td><td>For some reason the request was malformed. Will send a HTTP 400 response to the client.</td></tr>
    <tr><td><b>WSP_CANCEL_UNAVAILABLE</b></td><td>The requested resource is unavailable. Will send a HTTP 451 response to the client.</td></tr>
    <tr><td><b>WSP_CANCEL_MISSING_LENGTH</b></td><td>The request comes without a content length field. Will send a HTTP 411 response to the client.</td></tr>
    <tr><td><b>WSP_CANCEL_STREAM</b></td><td>Cancels an already started response stream. This is the only valid value to pass to cancel after the app started sending a response.
                                             Because canceling a stream normaly means, that an error occures, the webserver will send a HTTP 500
                                             response to the client, as long as the app has not send response data yet. If sending data (as stream
                                             or chunk encoded), the connection just will be closed by the webserver.</td></tr>
    <tr><td><b>WSP_CANCEL_ACCESS_DENIED</b></td><td>Access to the requested resource is denied. Will send a HTTP 402 response to the client.</td></tr>
    <tr><td><b>WSP_CANCEL_INTERNAL_ERROR</b></td><td>An internal error occured. Will send a HTTP 500 response to the client.</td></tr>
</table>

<h2><a name="wsp_path_type_t">wsp_path_type_t</a></h2>
<pre><code style="laguage-cpp">typedef enum {
    WSP_PATH_TYPE_HTTP,
    WSP_PATH_TYPE_WEBSOCKET,
    WSP_PATH_TYPE_PASSTHROUGH
} wsp_path_type_t;</code></pre>

<h3>Overview</h3>
This values will be passed to UWebserverPlugin::WebserverPluginRegisterPathResult() to tell for which listen call the callback had
been called.

<h3>Values</h3>
<table style="margin-left: 20px">
    <tr><td><b>WSP_PATH_TYPE_HTTP</b></td><td>The result for a HttpListen() call.</td></tr>
    <tr><td><b>WSP_PATH_TYPE_WEBSOCKET</b></td><td>The result for a WebsocketListen() call.</td></tr>
    <tr><td><b>WSP_PATH_TYPE_PASSTHROUGH</b></td><td>The result for a PassthroughListen() call.</td></tr>
</table>

<h2><a name="ws_webdav_result_t">ws_webdav_result_t</a></h2>
<pre><code style="laguage-cpp">typedef enum {
    WEBDAV_RESULT_OK = 0x100,
    WEBDAV_RESULT_CREATED,
    WEBDAV_RESULT_NO_CONTENT,
    WEBDAV_RESULT_MULTIPLE_STATUS,
    WEBDAV_RESULT_FORBIDDEN,
    WEBDAV_RESULT_METHOD_NOT_ALLOWED,
    WEBDAV_RESULT_CONFLICT,
    WEBDAV_RESULT_PRECONDITION_FAILED,
    WEBDAV_RESULT_LOCKED,
    WEBDAV_RESULT_BAD_GATEWAY,
    WEBDAV_RESULT_INSUFFICIENT_STORAGE
} ws_webdav_result_t;</code></pre>
    
<h3>Overview</h3>
This constants need to be send as result for each webdav hanlder. Sometimes the meaning of the values differ, depending what kind
of WebDAV request needs to be answered.
    
<h3>Values</h3>
<table style="margin-left: 20px">
    <tr><td><b>WEBDAV_RESULT_OK</b></td><td><b>OPTIONS, LOCK, DELETE, POLL:</b> The was successfull. Will send a HTTP 200 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_CREATED</b></td><td><b>PUT, MKCOL:</b> The resource was created successfully.<br/><b>MOVE:</b> The resource was moved successfully.<br/><b>LOCK:</b> The lock was done successfully.<br/>Will send a HTTP 201 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_NO_CONTENT</b></td><td><b>PUT, DELETE, UNLOCK, COPY, MOVE:</b> A standard success status code, when no additional data need to ben sent. Will send a HTTP 204 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_MULTIPLE_STATUS</b></td><td><b>PROPFIND, PROPPATCH, MKCOL, COPY, MOVE:</b> Multiple status will be send with the response. Will send a HTTP 207 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_FORBIDDEN</b></td><td><b>All:</b> The client does not have premision for the requested WebDAV method. Will send a HTTP 404 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_METHOD_NOT_ALLOWED</b></td><td><b>All:</b> The methos is not allowed for the resoure.<br/><b>MKCOL:</b> Can be used to tell the client, that the collection  already axists an cannot be created.<br/>Will send a HTTP 405 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_CONFLICT</b></td><td><b>MKCOL, PROPPATCH, PUT:</b> The WebDAV method could not be executed because of a conflict. Will send a HTTP 409 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_PRECONDITION_FAILED</b></td><td><b>COPY, MOVE:</b> The server was unable to maintain the availability of the properties listed in the property behaviour XML element.<br/><b>LOCK:</b> The lock token could not be enforced.<br/><b>COPY, PUT:</b> Evaluation of request header fields failed.<br/>Will send a HTTP 412 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_LOCKED</b></td><td><b>PROPPATCH, DELETE, MOVE:</b> The method can not change the properties.<br/><b>LOCK:</b> The resource is already locked.<br/><b>COPY:</b> The resource was locked.<br/>Will send a HTTP 423 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_BAD_GATEWAY</b></td><td><b>All:</b> The server (acting as gateway or proxy) received an invalid response from the upstream server. Will send a HTTP 502 response to the client.</td></tr>
    <tr><td><b>WEBDAV_RESULT_INSUFFICIENT_STORAGE</b></td><td><b>PROPPATCH, MKCOL, COPY:</b> The resource doesn't have enough space to execute the methid. Will send a HTTP 507 response ot the client.</td></tr>
</table>
    
<h2><a name="wsr_type_t">wsr_type_t</a></h2>
<pre><code style="laguage-cpp">typedef enum {
    // Start of resource file types
    WSP_RESPONSE_NO_TYPE = 0x100,
    WSP_RESPONSE_BINARY,
    WSP_RESPONSE_JAVA,
    WSP_RESPONSE_WAV,
    WSP_RESPONSE_OGG,
    WSP_RESPONSE_MP3,
    WSP_RESPONSE_GIF,
    WSP_RESPONSE_PNG,
    WSP_RESPONSE_BMP,
    WSP_RESPONSE_ICON,
    WSP_RESPONSE_TTF,
    WSP_RESPONSE_EOT,
    WSP_RESPONSE_PDF,
    WSP_RESPONSE_TEXT,
    WSP_RESPONSE_XML,
    WSP_RESPONSE_CSS,
    WSP_RESPONSE_JAVASCRIPT,
    WSP_RESPONSE_JSON,
    WSP_RESPONSE_HTML,
    WSP_RESPONSE_SVG,
    WSP_RESPONSE_WOFF,
    WSP_RESPONSE_G711,
    WSP_RESPONSE_G722,
    WSP_RESPONSE_G729,
    WSP_RESPONSE_JPEG,
    WSP_RESPONSE_MP4,
    WSP_RESPONSE_WEBM
} wsr_type_t;</code></pre>
    
<h3>Overview</h3>
When sending data for a GET request, the type of the resource send must be set in the response header. So the application must define
the type of the data to send passing of of the wsr_type_t values to IWebserverGet::SetTransferInfo(). The webserver will set the appropriate
MIME type for the Content-Type header field.<br/>
The names of that values are self-explanatory, except for WSP_RESPONSE_NO_TYPE (means that no MIME type will be set in the response header)
and WSP_RESPONSE_BINARY (a general binary data stream with MIME type application/octet-stream).<br/>
An application can use the <a href="#GetResponseTypeForFileName">GetResponseTypeForFileName()</a> function to determine the correct wsr_type_t value according
to the filename suffix.

<h2><a name="wsp_close_reason_t">wsp_close_reason_t</a></h2>
<pre><code style="laguage-cpp">typedef enum {
    WSP_NORMAL_CLOSE,                // The app itself initiated the shutdown
    WSP_REGISTER_PATH_INVALID,       // The given path is invalid
    WSP_WEBSOCKET_PATH_INVALID,      // The given Websocket listen path is invalid.
    WSP_WEBSOCKET_PATH_ALREADY_LISTENING, // Someone alrady is listening to that path for websocekt connections
    WSP_PATH_ALREADY_REGISTERD,      // A data provider already registered to that resource
    WSP_ADDRESS_INVALID,             // The address the application tried to connect to was invalid
    WSP_CONNECTION_ERROR             // An connection error occured (see log, if exists),
} wsp_close_reason_t;</code></pre>
    
<h3>Overview</h3>
One of theese values will be passed to UWebserverPlugin::WebserverPluginShutdownComplete() to determine the reason of the
shutdown. This close reasons here are for the WebserverPlugin itself.

<h3>Values</h3>
<table style="margin-left: 20px">
    <tr><td><b>WSP_NORMAL_CLOSE</b></td><td>A normal shutdown, initiated by the application itself.</td></tr>
    <tr><td><b>WSP_REGISTER_PATH_INVALID</b></td><td>The path given als applications root or passed to IWebserverPlugin::HttpListen() or IWebserverPlugin::PassthroughListen() is invalid.</td></tr>
    <tr><td><b>WSP_WEBSOCKET_PATH_INVALID</b></td><td>The path  als applications root or passed to IWebserverPlugin::WebsocketListen() is invalid.</td></tr>
    <tr><td><b>WSP_WEBSOCKET_PATH_ALREADY_LISTENING</b></td><td>The application called IWebserverPlugin::WebsocketListen() for a path someone already is listening to.</td></tr>
    <tr><td><b>WSP_PATH_ALREADY_REGISTERD</b></td><td>The application called IWebserverPlugin::HttpListen() or IWebserverPlugin::PassthroughListen() for a path someone already is registered to..</td></tr>
    <tr><td><b>WSP_ADDRESS_INVALID</b></td><td>The address the application try to connect to communicate with the webserver was invalid.</td></tr>
    <tr><td><b>WSP_CONNECTION_ERROR</b></td><td>A connection error occured (see log for details).</td></tr>
</table>


<h2><a name="ws_close_reason_t">ws_close_reason_t</a></h2>
<pre><code style="laguage-cpp">typedef enum {
    WSCR_NORMAL_CLOSE,
    WSCR_BUFFER_OVERFLOW,
    WSCR_SOCKET_LOST,
    WSCR_ERROR,
} ws_close_reason_t;</code></pre>
    
<h3>Overview</h3>
One of theese values will be passed to UWebsocket::WebsocketCloseComplete() to determine the reason why the websocket connection
had been closed. This values are for Websocket only.

<h3>Values</h3>
<table style="margin-left: 20px">
    <tr><td><b>WSCR_NORMAL_CLOSE</b></td><td>A normal close, initialted by th application or the client.</td></tr>
    <tr><td><b>WSCR_BUFFER_OVERFLOW</b></td><td>The connection had been closed because of an buffer overflow error.</td></tr>
    <tr><td><b>WSCR_SOCKET_LOST</b></td><td>The socket used for the connection had been lost.</td></tr>
    <tr><td><b>WSCR_ERROR</b></td><td>An error occured. See log for details.</td></tr>
</table>

<h2><a name="ws_request_type_t">ws_request_type_t</a></h2>
<pre><code style="laguage-cpp">typedef enum {
    WS_REQUEST_GET          = 0x0001,
    WS_REQUEST_POST         = 0x0002,
    WS_REQUEST_PUT          = 0x0004,
    WS_REQUEST_PASSTHROUGH  = 0x0008,
    WS_REQUEST_PROPFIND     = 0x0010,
    WS_REQUEST_MOVE         = 0x0020,
    WS_REQUEST_COPY         = 0x0040,
    WS_REQUEST_MKCOL        = 0x0080,
    WS_REQUEST_DELETE       = 0x0100,
    WS_REQUEST_OPTIONS      = 0x0200,
    WS_REQUEST_LOCK         = 0x0400,
    WS_REQUEST_UNLOCK       = 0x0800,
    WS_REQUEST_PROPPATCH    = 0x1000
} ws_request_type_t;</code></pre>
    
<h3>Overview</h3>
Theese values will be passed to UWebserverPlugin::WebserverPluginHttpListenResult() to define the type of th request. When accepting,
the application must call IWebserverPlugin::Accept() with a propriate request handler instance for that request.<br/>
<b>Note:</b> A request for a path the application is listening to buy calling IWebserverPlugin::PassthroughListen() before will lead
to an UWebserverPlugin::WebserverPluginPassthroughListenResult() callback. The WS_REQUEST_PASSTHROUGH enum type will only be used
internally and because of this never be passed to UWebserverPlugin::WebserverPluginHttpListenResult().
    
<h3>Values</h3>
<table style="margin-left: 20px">
    <tr><td><b>WS_REQUEST_GET</b></td><td>A GET request. Must be accepted with an <a href="#UWebserverGet">UWebserverGet</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_POST</b></td><td>A POST request. Must be accepted with an <a href="#UWebserverPost">UWebserverPost</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_PUT</b></td><td>A WebDAV PUT request. Must be accepted with an <a href="#UWebserverPut">UWebserverPut</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_PASSTHROUGH</b></td><td>Used internally only by IWebserverPlugin. A passthrough request reaches the application throuh UWebserverPlugin::WebserverPluginPassthroughListenResult() and must be accepted with an <a href="#UWebserverPassthrough">UWebserverPassthrough</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_PROPFIND</b></td><td>A WebDAV PROPFIND request. Must be accepted with an <a href="#UWebserverPropfind">UWebserverPropfind</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_MOVE</b></td><td>A WebDAV MOVE request. Must be accepted with an <a href="#UWebserverMove">UWebserverMove</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_COPY</b></td><td>A WebDAV COPY request. Must be accepted with an <a href="#UWebserverCopy">UWebserverCopy</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_MKCOL</b></td><td>A WebDAV MKCOL request. Must be accepted with an <a href="#UWebserverMkCol">UWebserverMkCol</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_DELETE</b></td><td>A WebDAV DELETE request. Must be accepted with an <a href="#UWebserverDelete">UWebserverDelete</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_OPTIONS</b></td><td>A WebDAV OPTIONS request. Must be accepted with an <a href="#UWebserverOptions">UWebserverOptions</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_LOCK</b></td><td>A WebDAV LOCK request. Must be accepted with an <a href="#UWebserverLock">UWebserverLock</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_UNLOCK</b></td><td>A WebDAV UNLOCK request. Must be accepted with an <a href="#UWebserverUnlock">UWebserverUnlock</a> instance.</td></tr>
    <tr><td><b>WS_REQUEST_PROPPATCH</b></td><td>A WebDAV PROPPATCH request. Must be accepted with an <a href="#UWebserverProppatch">UWebserverProppatch</a> instance.</td></tr>
</table>

<h2><a name="ws_update_auth_result_t">ws_update_auth_result_t</a></h2>
<pre><code style="laguage-cpp">typedef enum {
    WS_AUTH_DECACTIVATED,
    WS_AUTH_DYNAMIC,
    WS_AUTH_STATIC,
    WS_AUTH_ERR_PATH_NOT_LISTENING,
    WS_AUTH_ERR_PATH_INVALID
} ws_update_auth_result_t;</code></pre>
    
<h3>Overview</h3>
This are the results received by the webserver when changing the configuration for authentication by using <a href="#IWebserverPlugin">IWebserverPlugin</a>::SetAuthConfig().

<h3>Values</h3>
<table style="margin-left: 20px">
    <tr><td><b>WS_AUTH_DECACTIVATED</b></td><td>The authentication for the given path had been deactivated.</td></tr>
    <tr><td><b>WS_AUTH_DYNAMIC</b></td><td>The given path now uses dynamic authentication, which means that the webserver will ask the app for username / password.</td></tr>
    <tr><td><b>WS_AUTH_STATIC</b></td><td>The given path now uses static authentication with the username / password passed to the previous SetAuthConfig() call.</td></tr>
    <tr><td><b>WS_AUTH_ERR_PATH_NOT_LISTENING</b></td><td>SetAuthConfig() had been called for a path without calling IWebserverPlugin::HTTPListen() first.</td></tr>
    <tr><td><b>WS_AUTH_ERR_PATH_INVALID</b></td><td>SetAuthConfig() had been called for a path which doesn't belong to the IWebserverPlugin instance.</td></tr>
</table>

    
<h2><a name="IWebserverGetRange_range_type_t">IWebserverGetRange::range_type_t</a></h2>
<pre><code style="laguage-cpp">class IWebserverGetRange {
public:
    enum range_type_t {
        RANGE_NONE       = 0x00,
        RANGE_START_END  = 0x01,
        RANGE_START_ONLY = 0x02,
        RANGE_LAST_BYTES = 0x03
    } rangeType;
};</code></pre>
    
<h3>Overview</h3>
This are values to define the type of the range received with a GET request.
    
<h3>Values</h3>
<table style="margin-left: 20px">
    <tr><td><b>RANGE_NONE</b></td><td>There is no range sent with the request. This value is only used internally.</td></tr>
    <tr><td><b>RANGE_START_END</b></td><td>The range request defines the start and end bytes of the requested resource.</td></tr>
    <tr><td><b>RANGE_START_ONLY</b></td><td>The range request defines the start byte inside the resource. The application must send the data starting from this byte on the rest of the resource.</td></tr>
    <tr><td><b>RANGE_LAST_BYTES</b></td><td>The request defines the last bytes of the resource the application needs to send.</td></tr>
</table>

<h1>Structures</h1>
<h2><a name="ws_type_sfx_t">ws_type_sfx_t</a></h2>
<pre><code style="laguage-cpp">typedef struct {
    const char * sfx;
    wsr_type_t type;
} ws_type_sfx_t;
    
    
static const ws_type_sfx_t suffixes[] = {
    { "html", WSP_RESPONSE_HTML },
    { "htm", WSP_RESPONSE_HTML },
    { "css", WSP_RESPONSE_CSS },
    { "xml", WSP_RESPONSE_XML },
    { "xsl", WSP_RESPONSE_XML },
    { "js", WSP_RESPONSE_JAVASCRIPT },
    { "json", WSP_RESPONSE_JSON },
    { "ico", WSP_RESPONSE_ICON },
    { "bin", WSP_RESPONSE_BINARY },
    { "jar", WSP_RESPONSE_JAVA },
    { "png", WSP_RESPONSE_PNG },
    { "gif", WSP_RESPONSE_GIF },
    { "bmp", WSP_RESPONSE_BMP },
    { "pdf", WSP_RESPONSE_PDF },
    { "wav", WSP_RESPONSE_WAV },
    { "ogg", WSP_RESPONSE_OGG },
    { "mp3", WSP_RESPONSE_MP3 },
    { "txt", WSP_RESPONSE_TEXT },
    { "soap", WSP_RESPONSE_XML },
    { "svg", WSP_RESPONSE_SVG },
    { "ttf", WSP_RESPONSE_TTF },
    { "eot", WSP_RESPONSE_EOT },
    { "woff", WSP_RESPONSE_WOFF },
    { "woff2", WSP_RESPONSE_WOFF },
    { "g711a", WSP_RESPONSE_G711 },
    { "g711u", WSP_RESPONSE_G711 },
    { "g722", WSP_RESPONSE_G722 },
    { "g729", WSP_RESPONSE_G729 },
    { "jpeg", WSP_RESPONSE_JPEG },
    { "mp4", WSP_RESPONSE_MP4 },
    { "webm", WSP_RESPONSE_WEBM }
};</code></pre>
    
<h3>Overview</h3>
This structure, in conjunction with the suffixes[] array, is used by <a href="#GetResponseTypeForFileName">GetResponseTypeForFileName()</a> function
to determine the correct wsr_type_t value depending on the suffix of a filename.

<h3>Values</h3>
<table style="margin-left: 20px">
    <tr><td>const char * <b>sfx</b></td><td>The filename suffix.</td></tr>
    <tr><td>wsr_type_t <b>type</b></td><td>The wsr_type_t value for that suffix.</td></tr>
</table>


<h1> Code Example </h1>
<a name="ExampleIWebserverPlugin_IWebserverGet"><h2>IWebserverPlugin - IWebserverGet</h2></a>
<pre class="sample"><code class="language-cpp">app::app(IIoMux * iomux)
    : iomux(iomux)
{
    this->webserverPlugin = IWebserverPlugin::Create(iomux, this);
    this->webserverPlugin->RegisterForPath("/path/to/webserver", "/demoapp/main");
}

void app::WebserverPluginWebRequest(IWebserverPlugin * plugin, ws_request_type_t requestType, char * resourceName, ulong64 dataSize)
{
    if (requestType != WS_REQUEST_GET || strcmp(resourceName, "myresource.png") != 0)
        plugin->Cancel(WSP_CANCEL_NOT_FOUND);
    else {
        plugin->Accept(new MyGetHandler);
    }
}

// ==== MyGetHandler

class MyGetHandler {
protected:
    char * dataBuffer;
    ulong64 dataSize;
    ulong64 dataSend;

public:
    MyGetHandler() {}
    ~MyGetHandler() {}

    void WebserverGetRequestAcceptComplete(IWebserverGet * const webserverGet)
    {
        // We assume that there is a function that returns the http file instance...
        httpfile * myFile = GetFileForName(webserverGet->GetResourceName());

        dataBuffer = myFile->GetData();
        dataSize = myFile->GetSize();
        dataSend = 0;

        webserverGet->SetTransferInfo(wsr_type_t(myFile->GetResourceType()),
                                      myFile->GetSize(),
                                      wsr_flags_t(myFile->GetFlags()));

        this->SendNextPart(webserverGet);

    }

    void WebserverGetSendResult(IWebserverGet * const webserverGet)
    {
        this->SendNextPart(webserverGet);
    }

    void SendNextPart(IWebserverGet * const webserverGet)
    {
        ulong64 dataSize = staticFile->GetSize();

        if (bytesSend < dataSize) {
            ulong64 dataSizeDiff = dataSize - bytesSend;
            ulong64 sendSize = dataSizeDiff > WS_MAX_DATA_SIZE ? WS_MAX_DATA_SIZE : dataSizeDiff;
            webserverGet->Send((void *)(dataBuffer + bytesSend), sendSize);
            bytesSend += sendSize;
            if (bytesSend == dataSize)
                webserverGet->Close();
        }
    }


    void WebserverGetCloseComplete(IWebserverGet * const webserverGet)
    {
        delete webserverGet;
        delete this;
    }
};
</pre>

<a name="ExampleIWebserverPlugin_IWebsocket"><h2>IWebserverGet - IWebsocket</h2></a>
<pre class="sample"><code class="language-cpp">app::app(IIoMux * iomux)
    : iomux(iomux)
{
    this->webserverPlugin = IWebserverPlugin::Create(iomux, this);
    this->webserverPlugin->RegisterForPath("/path/to/webserver", "/demoapp/main");
    this->webserverPlugin->WebsocketListen();
}

void app::WebserverWebsocketListenResult(IWebserverPlugin * plugin, const char * path, const char * host)
{
    if (strcmp(host, "some-bad-host.de") == 0)
        this->webserverPlugin->Accept(nullptr); // Deny conection.
    else
        this->webserverPlugin->Accept(new appWebsocket());
}

// appWebsocket - user for IWebsocket

void appWebsocket::WebsocketAcceptComplete(class IWebsocket * websocket)
{
    this->websocketInst = websocket;
}

void appWebsocket::WebsocketSendResult(class IWebsocket * websocket)
{
    printf("Websocket data sent\n");
    this->websocketInst->Close();
}

void appWebsocket::WebsocketRecvResult(class IWebsocket * websocket, const void * buffer, size_t len, bool text)
{
    printf("Websocket - received data (text = %s)\n", (text ? "true" : "false"));
    debug->HexDump(buffer, len);
    this->websocketInst->Send(buffer, len, text);
}

void appWebsocket::WebsocketCloseComplete(class IWebsocket * websocket, ws_close_reason_t reason)
{
    delete this->websocketInst;
    delete this;
}
</pre>
</body>
</html>
